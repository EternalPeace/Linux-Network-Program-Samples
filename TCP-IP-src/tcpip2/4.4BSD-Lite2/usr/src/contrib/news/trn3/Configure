#! /bin/sh
#
# If these # comments don't work, trim them.  Don't worry about any other
# shell scripts, Configure will trim # comments from them for you.
#
# (If you are trying to port this package to a machine without sh,
# I would suggest you have a look at the prototypical config.h.SH file
# and edit it to reflect your system. Some packages may include samples
# of config.h for certain machines, so you might look for one of those.)
#
# Yes, you may rip this off to use in other distribution packages. This
# script belongs to the public domain and cannot be copyrighted.
#
# (Note: this Configure script was generated automatically. Rather than
# working with this copy of Configure, you may wish to get metaconfig.
# Write to either:
#
#     harlan@mumps.pfcs.com (Harlan Stenn)
#     ram@acri.fi (Raphael Manfredi)
#
# and we will send you -or point you to- the latest revision of the dist
# package, which includes metaconfig.)
#

# $Id: Head.U,v 2.8 91/07/08 13:30:13 ram Exp Locker: ram $
#
# Generated on Tue Mar  2 22:44:27 PST 1993 [metaconfig 2.9dev PL11]

cat >/tmp/c1$$ <<EOF
ARGGGHHHH!!!!!

SCO csh still thinks true is false.  Write to SCO today and tell them that next
year Configure ought to "rm /bin/csh" unless they fix their blasted shell. :-)

(Actually, Configure ought to just patch csh in place.  Hmm.  Hmmmmm.  All
we'd have to do is go in and swap the && and || tokens, wherever they are.)

[End of diatribe. We now return you to your regularly scheduled programming...]
EOF
cat >/tmp/c2$$ <<EOF

OOPS!  You naughty creature!  You didn't run Configure with sh!
I will attempt to remedy the situation by running sh for you...
EOF

true || cat /tmp/c1$$ /tmp/c2$$
true || exec sh $0 $argv:q

(exit $?0) || cat /tmp/c2$$
(exit $?0) || exec sh $0 $argv:q
rm -f /tmp/c1$$ /tmp/c2$$

: Sanity checks
PATH=".:$PATH:/bin:/usr/bin:/usr/local/bin:/usr/ucb:/usr/local:/usr/lbin"
PATH=$PATH:'/usr/5bin:/etc:/usr/gnu/bin:/usr/new:/usr/new/bin:/usr/nbin'
PATH=$PATH:'/sys5.3/bin:/sys5.3/usr/bin:/bsd4.3/bin:/bsd4.3/usr/ucb'
PATH=$PATH:'/bsd4.3/usr/bin:/usr/bsd:/bsd43/bin:/usr/ccs/bin'
PATH=$PATH:'/etc:/usr/lib:/usr/ucblib:/lib:/usr/ccs/lib'
export PATH

if test ! -t 0; then
	echo "Say 'sh Configure', not 'sh <Configure'"
	exit 1
fi

: Warn them if they use ksh
(alias) >/dev/null 2>&1 && \
	cat <<'EOM'
(I see you are using the Korn shell.  Some ksh's blow up on Configure,
especially on exotic machines.  If yours does, try the Bourne shell instead.)
EOM

: Configure runs within the UU subdirectory
test -d UU || mkdir UU
cd UU && rm -f *

cf_by=''
cf_time=''
d_bsd=''
d_eunice=''
d_xenix=''
eunicefix=''
Mcc=''
awk=''
bash=''
bison=''
cat=''
chgrp=''
chmod=''
chown=''
compress=''
cp=''
cpp=''
csh=''
date=''
echo=''
egrep=''
emacs=''
expr=''
flex=''
gcc=''
grep=''
inews=''
ispell=''
ispell_path=''
ispell_options=''
ksh=''
less=''
line=''
lint=''
ln=''
lp=''
lpr=''
ls=''
mail=''
mailx=''
make=''
mkdir=''
more=''
mv=''
nroff=''
perl=''
pg=''
pmake=''
pr=''
rm=''
rmail=''
sed=''
sendmail=''
shar=''
sleep=''
smail=''
sort=''
submit=''
tail=''
tar=''
tbl=''
test=''
touch=''
tr=''
troff=''
uname=''
uniq=''
uuname=''
vi=''
zcat=''
hint=''
myuname=''
Author=''
Date=''
Header=''
Id=''
Locker=''
Log=''
RCSfile=''
Revision=''
Source=''
State=''
active=''
acttimes=''
d_acttimes=''
myactive=''
bin=''
installbin=''
cc=''
ccflags=''
cppflags=''
ldflags=''
lkflags=''
optimize=''
contains=''
cppminus=''
cppstdin=''
d_bcmp=''
d_bcopy=''
d_bzero=''
d_ftime=''
aphostcmd=''
d_gethname=''
d_phostcmd=''
d_uname=''
d_getpwent=''
d_getcwd=''
d_getwd=''
d_havetlib=''
termlib=''
d_ignoreorg=''
d_internet=''
d_newsadm=''
newsadmin=''
d_nntp=''
d_xdata=''
servername=''
d_nolnbuf=''
d_normsig=''
jobslib=''
d_hvfork=''
d_novfork=''
d_novoid=''
void=''
d_portable=''
d_rdchk=''
d_rename=''
d_sigblock=''
d_sighold=''
d_sizet=''
d_strchr=''
d_strftime=''
d_libndir=''
d_usendir=''
libndir=''
ndirc=''
ndiro=''
d_voidsig=''
signal_t=''
defeditor=''
filexp=''
h_fcntl=''
h_sysfile=''
d_dirnamlen=''
i_dirent=''
i_fcntl=''
i_ptem=''
i_sysdir=''
d_voidtty=''
i_bsdioctl=''
i_sysioctl=''
i_syssockio=''
i_sysndir=''
i_sgtty=''
i_termio=''
i_termios=''
i_vfork=''
libc=''
plibpth=''
xlibpath=''
libs=''
citydist=''
cntrydist=''
contdist=''
locdist=''
orgdist=''
statedist=''
mailer=''
mailfile=''
manext=''
mansrc=''
mboxchar=''
c=''
n=''
d_berknames=''
d_passnames=''
d_usgnames=''
nametype=''
passcat=''
inewsloc=''
newslib=''
newslibexp=''
newsspool=''
orgname=''
package=''
pager=''
phost=''
phostcmd=''
prefshell=''
installprivlib=''
privlib=''
rootid=''
sharpbang=''
shsharp=''
spitshell=''
startsh=''
sysman=''
d_usemt=''
d_useov=''
overviewdir=''
threaddir=''
trn_init=''
trn_select=''
nm_opt=''
runnm=''
usenm=''
incpath=''
mips=''
mips_type=''
usrinc=''
d_whoami=''
i_sysfile=''
i_sysselct=''
large=''
CONFIG=''

: script used to extract .SH files with variable substitutions
cat >extract <<'EOS'
CONFIG=true
echo "Doing variable substitutions on .SH files..."
if test -f MANIFEST; then
	set x `awk '{print $1}' <MANIFEST | $grep '\.SH'`
else
	echo "(Looking for .SH files under the current directory.)"
	set x `find . -name "*.SH" -print`
fi
shift
case $# in
0) set x *.SH; shift;;
esac
if test ! -f $1; then
	shift
fi
for file in $*; do
	case "$file" in
	*/*)
		dir=`$expr X$file : 'X\(.*\)/'`
		file=`$expr X$file : 'X.*/\(.*\)'`
		(cd $dir && . ./$file)
		;;
	*)
		. ./$file
		;;
	esac
done
EOS

: process the command line options
set X `for arg in "$@"; do echo $arg; done | awk '
BEGIN {
	optstr = "deEf:hrsSV";	# getopt-style specification

	len = length(optstr);
	for (i = 1; i <= len; i++) {
		c = substr(optstr, i, 1);
		if (i < len) a = substr(optstr, i + 1, 1); else a = "";
		if (a == ":") {
			arg[c] = 1;
			i++;
		}
		opt[c] = 1;
	}
}
{
	expect = 0;
	str = $0;
	if (substr(str, 1, 1) != "-") {
		printf("'"'%s'"'\n", str);
		next;
	}
	len = length($0);
	for (i = 2; i <= len; i++) {
		c = substr(str, i, 1);
		if (!opt[c]) {
			printf("-%s\n", substr(str, i));
			next;
		}
		printf("-%s\n", c);
		if (arg[c]) {
			if (i < len)
				printf("'"'%s'"'\n", substr(str, i + 1));
			else
				expect = 1;
			next;
		}
	}
}
END {
	if (expect)
		print "?";
}
'`
eval "set $*"
shift
		
: set up default values
fastread=''
reuseval=false
config_sh=''
alldone=''
error=''
silent=''
extractsh=''

: option parsing
while test $# -gt 0; do
	case "$1" in
	-d) shift; fastread=yes;;
	-e) shift; alldone=cont;;
	-f)
		shift
		cd ..
		if test -r "$1"; then
			config_sh="$1"
		else
			echo "Configure: cannot read config file $1." >&2
			error=true
		fi
		cd UU
		shift;;
	-h) shift; error=true;;
	-r) shift; reuseval=true;;
	-s) shift; silent=true;;
	-E) shift; alldone=exit;;
	-S) shift; extractsh=true;;
	-V) echo "Configure generated by metaconfig 2.9dev PL11." >&2
		exit 0;;
	--) break;;
	-*) echo "Configure: unknown option $1" >&2; shift; error=true;;
	*) break;;
	esac
done

case "$error" in
true)
	cat >&2 <<EOM
Usage: Configure [-dehrESV] [-f config.sh]
  -d : use defaults for all answers.
  -e : go on without questioning past the production of config.sh.
  -f : specify an alternate default configuration file.
  -h : print this help message and exit (with an error status).
  -r : reuse C symbols value if possible (skips costly nm extraction).
  -s : silent mode, only echoes questions and essential information.
  -E : stop at the end of questions, after having produced config.sh.
  -S : perform variable substitutions on all .SH files (can mix with -f)
  -V : print version number and exit (with a zero status).
EOM
	exit 1
	;;
esac

exec 4>&1
case "$silent" in
true) exec 1>/dev/null;;
esac

case "$extractsh" in
true)
	case "$config_sh" in
	'') config_sh='config.sh'; config='./config.sh';;
	/*) config="$config_sh";;
	*) config="./$config_sh";;
	esac
	echo " "
	echo "Fetching answers from $config_sh..."
	cd ..
	. ./$config
	echo " "
	. ./UU/extract
	rm -rf UU
	echo "Done."
	exit 0
	;;
esac

: set package name
package=trn

: Eunice requires " " instead of "", can you believe it
echo " "
: Here we go...
echo "Beginning of configuration questions for $package."

define='define'
undef='undef'
smallmach='pdp11 i8086 z8000 i80286 iAPX286'
rmlist=''

trap 'echo " "; rm -rf $rmlist; exit 1' 1 2 3 15

: We must find out about Eunice early
eunicefix=':'
if test -f /etc/unixtovms; then
	eunicefix=/etc/unixtovms
fi
if test -f /etc/unixtovms.exe; then
	eunicefix=/etc/unixtovms.exe
fi

: list of known cpp symbols
attrlist="DGUX M_I186 M_I286 M_I386 M_I8086 M_XENIX UTS __DGUX__"
attrlist="$attrlist _AIX __STDC__ __m88k__ ansi bsd4_2 gcos gimpel"
attrlist="$attrlist hp9000s300 hp9000s400 hp9000s500 hp9000s700"
attrlist="$attrlist hp9000s800 hpux"
attrlist="$attrlist i186 i386 i486 i8086 iAPX286 ibm interdata"
attrlist="$attrlist m88k mc300 mc500 mc68000 mc68k mc700 mert"
attrlist="$attrlist mips NeXT ns16000 ns32000 nsc32000 os pdp11 posix"
attrlist="$attrlist pyr sinix sony sparc sun tower tower32 tower32_600"
attrlist="$attrlist tower32_800 tss u3b2 u3b20 u3b200 u3b5 ultrix unix"
attrlist="$attrlist vax venix xenix z8000"

: change the next line if compiling for Xenix/286 on Xenix/386
xlibpath='/usr/lib/386 /lib/386'

: general looking path for locating libraries
libpth='/usr/lib/large /lib '$xlibpth' /lib/large /usr/lib/small /lib/small'

: no include file wanted by default
inclwanted='/usr/include/NET-5000'

libswanted='malloc bsd socket bsdipc sun net hdb bbn str inet nls nsl c_s intl x'

: Now test for existence of everything in MANIFEST
echo " "
if test -f ../MANIFEST; then
	echo "First let's make sure your kit is complete.  Checking..." >&4
	awk '$1 !~ /PACK[A-Z]+/ {print $1}' ../MANIFEST | split -50
	rm -f missing
	for filelist in x??; do
		(cd ..; ls `cat UU/$filelist` >/dev/null 2>>UU/missing)
	done
	if test -s missing; then
		cat missing
		cat >&4 <<'EOM'

THIS PACKAGE SEEMS TO BE INCOMPLETE.

You have the option of continuing the configuration process, despite the
distinct possibility that your kit is damaged, by typing 'y'es.  If you
do, don't blame me if something goes wrong.  I advise you to type 'n'o
and contact the author (davison@borland.com).

EOM
		echo "[Type 'yes' to continue]" >&4
		read ans
		case "$ans" in
		y*)
			echo "Continuing..." >&4
			rm -f missing
			;;
		*)
			echo "ABORTING..." >&4
			kill $$
			;;
		esac
	else
		echo "Looks good..." >&4
	fi
else
	echo "There is no MANIFEST file.  I hope your kit is complete !"
fi
rm -f missing x??

: Some greps do not return status, grrr.
echo "grimblepritz" >grimble
if grep blurfldyick grimble >/dev/null 2>&1 ; then
	contains=contains
elif grep grimblepritz grimble >/dev/null 2>&1 ; then
	contains=grep
else
	contains=contains
fi
rm -f grimble
: the following should work in any shell
case "$contains" in
contains*)
	echo " "
	echo "AGH!  Grep doesn't return a status.  Attempting remedial action."
	cat >contains <<'EOSS'
grep "$1" "$2" >.greptmp && cat .greptmp && test -s .greptmp
EOSS
chmod +x contains
esac

: first determine how to suppress newline on echo command
echo " "
echo "Checking echo to see how to suppress newlines..."
(echo "hi there\c" ; echo " ") >.echotmp
if $contains c .echotmp >/dev/null 2>&1 ; then
	echo "...using -n."
	n='-n'
	c=''
else
	cat <<'EOM'
...using \c
EOM
	n=''
	c='\c'
fi
echo $n "The star should be here-->$c"
echo '*'
rm -f .echotmp

: compute the number of columns on the terminal for proper question formatting
case "$COLUMNS" in
'') COLUMNS='80';;
esac

: set up the echo used in my read
myecho="case \"\$xxxm\" in
'') echo $n \"\$rp $c\" >&4;;
*) case \"\$rp\" in
	'') echo $n \"[\$xxxm] $c\";;
	*)
		if test \`echo \"\$rp [\$xxxm]  \" | wc -c\` -ge $COLUMNS; then
			echo \"\$rp\" >&4
			echo $n \"[\$xxxm] $c\" >&4
		else
			echo $n \"\$rp [\$xxxm] $c\" >&4
		fi
		;;
	esac;;
esac"

: now set up to do reads with possible shell escape and default assignment
cat <<EOSC >myread
xxxm=\$dflt
$myecho
ans='!'
case "\$fastread" in
yes) case "\$dflt" in
	'') ;;
	*) ans='';
		case "\$silent-\$rp" in
		true-) ;;
		*) echo " " >&4;;
		esac;;
	esac;;
*) case "\$silent" in
	true) case "\$rp" in
		'') ans='';;
		esac;;
	esac;;
esac
while expr "X\$ans" : "X!" >/dev/null; do
	read answ
	set x \$xxxm
	shift
	aok=''; eval "ans=\"\$answ\"" && aok=y
	case  "\$answ" in
	"\$ans")
		case "\$ans" in
		"!")
			sh 1>&4
			echo " "
			$myecho
			;;
		!*)
			set x \`expr "X\$ans" : "X!\(.*\)\$"\`
			shift
			sh 1>&4 -c "\$*"
			echo " "
			$myecho
			;;
		esac;;
	*)
		case "\$aok" in
		y)
			echo "*** Substitution done -- please confirm."
			xxxm="\$ans"
			ans=\`echo $n "\$ans$c" | tr '\012' ' '\`
			xxxm="\$ans"
			ans=!
			;;
		*)
			echo "*** Error -- try again."
			ans=!
			;;
		esac
		$myecho
		;;
	esac
done
case "\$ans" in
'') ans="\$xxxm";;
esac
EOSC

: see if sh knows # comments
echo " "
echo "Checking your sh to see if it knows about # comments..." >&4
if sh -c '#' >/dev/null 2>&1 ; then
	echo "Your sh handles # comments correctly."
	shsharp=true
	spitshell=cat
	echo " "
	echo "Okay, let's see if #! works on this system..."
	echo "#!/bin/cat" >try
	$eunicefix try
	chmod +x try
	try > today
	if test -s today; then
		echo "It does."
		sharpbang='#!'
	else
		echo "#! /bin/cat" > try
		$eunicefix try
		chmod +x try
		try > today
		if test -s today; then
			echo "It does."
			sharpbang='#! '
		else
			echo "It doesn't."
			sharpbang=': use '
		fi
	fi
else
	echo "Your sh doesn't grok # comments--I will strip them later on."
	shsharp=false
	echo "exec grep -v '^[ 	]*#'" >spitshell
	chmod +x spitshell
	$eunicefix spitshell
	spitshell=`pwd`/spitshell
	echo "I presume that if # doesn't work, #! won't work either!"
	sharpbang=': use '
fi
rm -f try today

: figure out how to guarantee sh startup
echo " "
echo "Checking out how to guarantee sh startup..." >&4
case "$SYSTYPE" in
*bsd*|sys5*) startsh=$sharpbang"/$SYSTYPE/bin/sh";;
*) startsh=$sharpbang'/bin/sh';;
esac
echo "Let's see if '$startsh' works..."
cat >try <<EOSS
$startsh
set abc
test "$?abc" != 1
EOSS

chmod +x try
$eunicefix try
if ./try; then
	echo "Yup, it does."
else
echo "Nope.  You may have to fix up the shell scripts to make sure sh runs them."
fi
rm -f try

: general instructions
cat <<EOH
 
This installation shell script will examine your system and ask you questions
to determine how the trn package should be installed.  If you get stuck
on a question, you may use a ! shell escape to start a subshell or execute a
command.  Many of the questions will have default answers in square brackets;
typing carriage return will give you the default.

On some of the questions which ask for file or directory names you are allowed
to use the ~name construct to specify the login directory belonging to "name",
even if you don't have a shell which knows about that.  Questions where this is
allowed will be marked "(~name ok)".

EOH
rp=''
dflt='Type carriage return to continue'
. ./myread
cat <<'EOH'

The prompter used in this script allows you to use shell variables and
backticks in your answers.  You may use $1, $2, etc...  to refer to the words
in the default answer, as if the default line was a set of arguments given to a
script shell.  This means you may also use $* to repeat the whole default line,
so you do not have to re-type everything to add something to the default.

Everytime there is a substitution, you will have to confirm.  If there is an
error (e.g. an unmatched backtick), the default answer will remain unchanged
and you will be prompted again.

If you are in a hurry, you may run 'Configure -d'.  This will bypass nearly all
the questions and use the computed defaults (or the previous answers if there
was already a config.sh file).

EOH
. ./myread
cat <<EOH

Much effort has been expended to ensure that this shell script will run on any
Unix system.  If despite that it blows up on yours, your best bet is to edit
Configure and run it again.  Also, let me (davison@borland.com)
know how I blew it.  If you can't run Configure for some reason, you'll have to
generate a config.sh file by hand.

This installation script affects things in two ways:

1) it may do direct variable substitutions on some of the files included
   in this kit.
2) it builds a config.h file for inclusion in C programs.  You may edit
   any of these files as the need arises after running this script.

If you make a mistake on a question, there is no easy way to back up to it
currently.  The easiest thing to do is to edit config.sh and rerun all the SH
files.  Configure will offer to let you do this before it runs the SH files.

EOH
dflt='Type carriage return to continue'
. ./myread

: find out where common programs are
echo " "
echo "Locating common programs..." >&4
cat <<EOSC >loc
$startsh
case \$# in
0) exit 1;;
esac
thing=\$1
shift
dflt=\$1
shift
for dir in \$*; do
	case "\$thing" in
	.)
	if test -d \$dir/\$thing; then
		echo \$dir
		exit 0
	fi
	;;
	*)
	if test -f \$dir/\$thing; then
		echo \$dir/\$thing
		exit 0
	elif test -f \$dir/\$thing.exe; then
		: on Eunice apparently
		echo \$dir/\$thing
		exit 0
	fi
	;;
	esac
done
echo \$dflt
exit 1
EOSC
chmod +x loc
$eunicefix loc
loclist="
awk
cat
cp
echo
expr
grep
mkdir
mv
rm
sed
sort
tail
tr
uniq
"
trylist="
Mcc
bash
cpp
csh
date
egrep
inews
ispell
ksh
less
mail
more
nroff
pg
rmail
sendmail
smail
test
uname
uuname
vi
"
pth=`echo $PATH | sed -e 's/:/ /g'`
pth="$pth /lib /usr/lib"
for file in $loclist; do
	xxx=`./loc $file $file $pth`
	eval $file=$xxx
	eval _$file=$xxx
	case "$xxx" in
	/*)
		echo $file is in $xxx.
		;;
	*)
		echo "I don't know where $file is.  I hope it's in everyone's PATH."
		;;
	esac
done
echo " "
echo "Don't worry if any of the following aren't found..."
ans=offhand
for file in $trylist; do
	xxx=`./loc $file $file $pth`
	eval $file=$xxx
	eval _$file=$xxx
	case "$xxx" in
	/*)
		echo $file is in $xxx.
		;;
	*)
		echo "I don't see $file out there, $ans."
		ans=either
		;;
	esac
done
case "$egrep" in
egrep)
	echo "Substituting grep for egrep."
	egrep=$grep
	;;
esac
case "$test" in
test)
	echo "Hopefully test is built into your sh."
	;;
/bin/test)
	if sh -c "PATH= test true" >/dev/null 2>&1; then
		echo "Using the test built into your sh."
		test=test
	fi
	;;
*)
	test=test
	;;
esac
case "$echo" in
echo)
	echo "Hopefully echo is built into your sh."
	;;
/bin/echo)
	echo " "
echo "Checking compatibility between /bin/echo and builtin echo (if any)..." >&4
	$echo $n "hi there$c" >foo1
	echo $n "hi there$c" >foo2
	if cmp foo1 foo2 >/dev/null 2>&1; then
		echo "They are compatible.  In fact, they may be identical."
	else
		case "$n" in
		'-n') n='' c='\c';;
		*) n='-n' c='';;
		esac
		cat <<FOO
They are not compatible!  You are probably running ksh on a non-USG system.
I'll have to use /bin/echo instead of the builtin, since Bourne shell doesn't
have echo built in and we may have to run some Bourne shell scripts.  That
means I'll have to use $ans to suppress newlines now.  Life is ridiculous.

FOO
		$echo $n "The star should be here-->$c"
		$echo "*"
	fi
	$rm -f foo1 foo2
	;;
*)
	: cross your fingers
	echo=echo
	;;
esac

: Try to determine whether config.sh was made on this system
xxx=`( ($uname -a) 2>/dev/null || hostname) 2>&1`
case "$config_sh" in
'')
dflt=n
if test -f ../config.sh; then
	eval "`grep myuname= ../config.sh`"
	if test "X$xxx" = "X$myuname"; then
		dflt=y
	fi
fi

: Get old answers, if there is a config file out there
hint=default
if test -f ../config.sh; then
	echo " "
	rp="I see a config.sh file.  Do you want to use it to set the defaults?"
	. ./myread
	case "$ans" in
	n*|N*) echo "OK, I'll ignore it.";;
	*)  echo "Fetching default answers from your old config.sh file..." >&4
		tmp="$n"
		ans="$c"
		. ../config.sh
		cp ../config.sh .
		n="$tmp"
		c="$ans"
		hint=previous
		;;
	esac
fi
;;
*)
	echo " "
	echo "Fetching default answers from $config_sh..." >&4
	tmp="$n"
	ans="$c"
	cd ..
	cp $config_sh config.sh 2>/dev/null
	. ./config.sh
	cd UU
	cp ../config.sh .
	n="$tmp"
	c="$ans"
	hint=previous
	;;
esac
myuname=$xxx

: Restore computed paths
for file in $loclist $trylist; do
	eval $file="\$_$file"
done

: set up shell script to do ~ expansion
cat >filexp <<EOSS
$startsh
: expand filename
case "\$1" in
 ~/*|~)
	echo \$1 | $sed "s|~|\${HOME-\$LOGDIR}|"
	;;
 ~*)
	if $test -f /bin/csh; then
		/bin/csh -f -c "glob \$1"
		failed=$?
		echo ""
		exit \$failed
	else
		name=\`$expr x\$1 : '..\([^/]*\)'\`
		dir=\`$sed -n -e "/^\${name}:/{s/^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:\([^:]*\).*"'\$'"/\1/" -e p -e q -e '}' </etc/passwd\`
		if $test ! -d "\$dir"; then
			me=\`basename \$0\`
			echo "\$me: can't locate home directory for: \$name" >&2
			exit 1
		fi
		case "\$1" in
		*/*)
			echo \$dir/\`$expr x\$1 : '..[^/]*/\(.*\)'\`
			;;
		*)
			echo \$dir
			;;
		esac
	fi
	;;
*)
	echo \$1
	;;
esac
EOSS
chmod +x filexp
$eunicefix filexp

: check if NNTP is to be used
case "$d_nntp" in
"$define") dflt="y";;
*)	   dflt="n";;
esac
$echo " "
rp="Do you want to access news via NNTP?"
. ./myread
case "$ans" in
n*)	d_nntp="$undef" d_xdata="$undef";;
y*)	d_nntp="$define"
	case "$d_xdata" in
	define) dflt="y";;
	*)	dflt="n";;
	esac
	$cat <<'EOM'

Trn allows you to use an after-market data-sending extension to NNTP
instead of a locally-maintained database (XTHREAD and XOVER are both
currently supported).
EOM
	rp="Do you want to access a remote database via NNTP?"
	. ./myread
	case "$ans" in
	y*) d_xdata="$define" ;;
	*)  d_xdata="$undef" ;;
	esac
	newsspool=/tmp
	$echo "net.foobar 00001 00001 y" > .falseactive

	case "$servername" in
	'')  dflt="no default" ;;
	*)   dflt="$servername";;
	esac

	$cat <<'EOM'

Trn needs to know what machine you wish to use as a news server.  You
can specify a machine name directly, or a filename from which to read
the name (start the name with a slash or a tilde to distinguish it).
Note also that the environment variable NNTPSERVER can be used for
individuals to override this default setting.

EOM

	rp="Enter a file name (~name ok) or machine name:"
	. ./myread
	ans=`./filexp "$ans"`
	case "$ans" in
	/*) if $test ! -f $ans; then
		$echo "(You'll need to create $ans before trn will work.)"
	    fi;;
	esac
	servername="$ans"
esac

: decide how portable to be
case "$d_portable" in
"$define") dflt=y;;
*)	dflt=n;;
esac
$cat <<'EOH'
 
I can set things up so that your shell scripts and binaries are more portable,
at what may be a noticable cost in performance.  In particular, if you
ask to be portable, the following happens:

     1) Shell scripts will rely on the PATH variable rather than using
	the paths derived above.
     2) ~username interpretations will be done at run time rather than
	by Configure.
     3) The system name will be determined at run time, if at all possible.

EOH
rp="Do you expect to run these scripts and binaries on multiple machines?"
. ./myread
case "$ans" in
	y*) d_portable="$define"
	for file in $loclist; do
		eval $file=$file
	done
	;;
	*)  d_portable="$undef" ;;
esac

: now set up to get a file name with possible "~name" substitutions
cat <<'EOSC' >getfile
tilde=''
fullpath=''
already=''
skip=''
none_ok=''
orig_rp="$rp"
orig_dflt="$dflt"

case "$fn" in
*~*) tilde=true;;
esac
case "$fn" in
*/*) fullpath=true;;
esac
case "$fn" in
*+*) skip=true;;
esac
case "$fn" in
*n*) none_ok=true;;
esac

case "$fn" in
*f*) type='File';;
*d*) type='Directory';;
*l*) type='Locate'; fn=`expr $fn : '.*:\(.*\)'`;;
esac

what="$type"
case "$what" in
Locate) what='File';;
esac

while test "$type"; do
	redo=''
	rp="$orig_rp"
	dflt="$orig_dflt"
	case "$tilde" in
	true) rp="$rp (~name ok)";;
	esac
	. ./myread
	case "$ans" in
	none)
		value=''
		case "$none_ok" in
		true) type='';;
		esac
		;;
	*)
		case "$tilde" in
		'') value="$ans";;
		*)
			value=`./filexp $ans`
			case $? in
			0)
				if test "$ans" != "$value"; then
					echo "(That is $value on this particular system.)"
				fi
				;;
			*) value="$ans";;
			esac
			case "$d_portable" in
			"$define") value="$ans";;
			esac
			;;
		esac
		case "$fullpath" in
		true)
			case "$value" in
			/*) ;;
			*)
				redo=true
				case "$already" in
				true)
				echo "I shall only accept a full path name, as in /bin/ls." >&4
				echo "Use a ! shell escape if you wish to check pathnames." >&4
					;;
				*)
				echo "Please give a full path name, starting with slash." >&4
					case "$tilde" in
					true)
				echo "Note that using ~name is ok provided it expands well." >&4
						already=true
						;;
					esac
				esac
				;;
			esac
			;;
		esac
		case "$redo" in
		'')
			case "$type" in
			File)
				if test -f "$value"; then
					type=''
				elif test -r "$value" || (test -h "$value") >/dev/null 2>&1
				then
					echo "($value is not a plain file, but that's ok.)"
					type=''
				fi
				;;
			Directory)
				if test -d "$value"; then
					type=''
				fi
				;;
			Locate)
				if test -d "$value"; then
					echo "(Looking for $fn in directory $value.)"
					value="$value/$fn"
				fi
				if test -f "$value"; then
					type=''
				fi
				;;
			esac

			case "$skip" in
			true) type='';
			esac

			case "$type" in
			'') ;;
			*)
				if test "$fastread" = yes; then
					dflt=y
				else
					dflt=n
				fi
				rp="$what $value doesn't exist.  Use that name anyway?"
				. ./myread
				dflt=''
				case "$ans" in
				y*) type='';;
				*) echo " ";;
				esac
				;;
			esac
			;;
		esac
		;;
	esac
done
ans="$value"
rp="$orig_rp"
dflt="$orig_dflt"
EOSC

: figure out news library
case "$d_nntp" in
define) newslib=/tmp
	newslibexp=/tmp
	;;
*)	case "$newslib" in
	'') dflt=/usr/lib/news;;
	*)  dflt=$newslib;;
	esac
	$echo " "
	fn=d~
	rp='Where is the news library directory?'
	. ./getfile
	newslib="$ans"
	newslibexp=`./filexp $newslib`
	if $test -f $newslibexp/inews; then
		$echo "Aha!  Inews is really in $newslibexp!" >&4
		case "$inews" in
		inews) : null;;
		*) $echo "(Make sure $inews isn't an old version.)";;
		esac
		inews=$newslibexp/inews
	fi
esac
case "$inewsloc" in
'') dflt="$inews";;
*)  dflt="$inewsloc";;
esac
$echo " "
fn=l:inews
rp='Which inews should be used for posting articles?'
. ./getfile
inewsloc="$ans"

: locate active file and active.times file
$echo " "
case "$d_nntp" in
define) active=none
	myactive=.falseactive
	: check for active.times
	case "$acttimes" in
	''|none) dflt="n";;
	*)       dflt="y";;
	esac
	cat <<'EOM'

If your server maintains an accurate "active.times" file, trn can make use
of the NEWGROUPS call in NNTP to find new groups instead of using the old
method of adding all groups not listed in your .newsrc.  If you aren't sure,
guess and see if you get notified of the new groups as they are created.

EOM
	rp="Does your server support a reliable NEWGROUPS call?"
	. ./myread
	case "$ans" in
	y*) acttimes="nntp" d_acttimes="$define";;
	*)  acttimes='none' d_acttimes="$undef";;
	esac
	;;
*)	case "$active" in
	'') dflt=$newslib/active ;;
	*)  dflt="$active";;
	esac
	fn=l~:active
	rp='Where is the active file?'
	. ./getfile
	active="$ans"
	myactive=`./filexp $active`
	: check for active.times
	case "$acttimes" in
	''|nntp) dflt="${active}.times";;
	*)       dflt="$acttimes";;
	esac
	$cat <<'EOM'

If your news system maintains an "active.times" file, trn can use it for a
fast new-group check.  If it's not around, answer "none" and the active
file will be scanned for new groups when it changes size.

EOM
	fn=ln~:active.times
	rp='The full pathname of active.times or "none"?'
	. ./getfile
	acttimes="$ans"
	case "$acttimes" in
	'') acttimes=none d_acttimes="$undef";;
	*) d_acttimes="$define";;
	esac
esac

: determine where manual pages are on this system
echo " "
case "$sysman" in
'') sysman=`loc . /usr/man/man1 /usr/man/man1 /usr/man/mann /usr/man/manl /usr/man/local/man1 /usr/man/u_man/man1 /usr/share/man/man1 /usr/catman/u_man/man1 /usr/man/l_man/man1 /usr/local/man/u_man/man1 /usr/local/man/l_man/man1 /usr/man/man.L`
	;;
esac
if $test -d "$sysman"; then
	echo "System manual is in $sysman." >&4
else
	echo "Could not find manual pages in source form." >&4
fi

: make some quick guesses about what we are up against
echo " "
$echo $n "Hmm...  $c"
$cat /usr/include/signal.h /usr/include/sys/signal.h >foo 2>/dev/null
if test `echo abc | tr a-z A-Z` = Abc ; then
	xxx=`./loc addbib blurfl $pth`
	if $test -f $xxx; then
	echo "Looks kind of like a USG system with BSD features, but we'll see..."
		echo exit 0 >bsd
		echo exit 0 >usg
		echo exit 1 >v7
	else
		if $contains SIGTSTP foo >/dev/null 2>&1 ; then
			echo "Looks kind of like an extended USG system, but we'll see..."
		else
			echo "Looks kind of like a USG system, but we'll see..."
		fi
		echo exit 1 >bsd
		echo exit 0 >usg
		echo exit 1 >v7
	fi
	d_bsd="$undef"
elif $contains SIGTSTP foo >/dev/null 2>&1 ; then
	echo "Looks kind of like a BSD system, but we'll see..."
	d_bsd="$define"
	echo exit 0 >bsd
	echo exit 1 >usg
	echo exit 1 >v7
else
	echo "Looks kind of like a Version 7 system, but we'll see..."
	d_bsd="$undef"
	echo exit 1 >bsd
	echo exit 1 >usg
	echo exit 0 >v7
fi
case "$eunicefix" in
*unixtovms*)
	$cat <<'EOI'
There is, however, a strange, musty smell in the air that reminds me of
something...hmm...yes...I've got it...there's a VMS nearby, or I'm a Blit.
EOI
	echo "exit 0" >eunice
	d_eunice="$define"
: it so happens the Eunice I know will not run shell scripts in Unix format
	;;
*)
	echo " "
	echo "Congratulations.  You aren't running Eunice."
	d_eunice="$undef"
	echo "exit 1" >eunice
	;;
esac
if test -f /xenix; then
	echo "Actually, this looks more like a XENIX system..."
	echo "exit 0" >xenix
	d_xenix="$define"
else
	echo " "
	echo "It's not Xenix..."
	echo "exit 1" >xenix
	d_xenix="$undef"
fi
chmod +x xenix
$eunicefix xenix
if test -f /venix; then
	echo "Actually, this looks more like a VENIX system..."
	echo "exit 0" >venix
else
	echo " "
	if xenix; then
		: null
	else
		echo "Nor is it Venix..."
	fi
	echo "exit 1" >venix
fi
chmod +x bsd usg v7 eunice venix
$eunicefix bsd usg v7 eunice venix
$rm -f foo

: see if we need a special compiler
echo " "
if usg; then
	case "$cc" in
	'') case "$Mcc" in
		/*) dflt='Mcc';;
		*) case "$large" in
			-M*) dflt='cc';;
			*)	if $contains '\-M' $sysman/cc.1 >/dev/null 2>&1 ; then
					if $contains '\-M' $sysman/cpp.1 >/dev/null 2>&1; then
						dflt='cc'
					else
						dflt='cc -M'
					fi
				else
					dflt='cc'
				fi;;
			esac;;
		esac;;
	*)  dflt="$cc";;
	esac
	$cat <<'EOM'
On some systems the default C compiler will not resolve multiple global
references that happen to have the same name.  On some such systems the "Mcc"
command may be used to force these to be resolved.  On other systems a "cc -M"
command is required.  (Note that the -M flag on other systems indicates a
memory model to use!) If you have the Gnu C compiler, you might wish to use
that instead.

EOM
	rp="What command will force resolution on this system?"
	. ./myread
	cc="$ans"
else
	case "$cc" in
	'') dflt=cc;;
	*) dflt="$cc";;
	esac
	rp="Use which C compiler?"
	. ./myread
	cc="$ans"
fi
case "$cc" in
gcc*) cpp=`loc gcc-cpp $cpp $pth`;;
esac

: What should the include directory be ?
echo " "
$echo $n "Hmm...  $c"
case "$usrinc" in
'') dflt='/usr/include';;
*) dflt=$usrinc;;
esac
incpath=''
mips_type=''
if $test -f /bin/mips && /bin/mips; then
	echo "Looks like a MIPS system..."
	$cat >usr.c <<'EOCP'
#ifdef SYSTYPE_BSD43
/bsd43
#endif
EOCP
	if $cc -E usr.c > usr.out && $contains / usr.out >/dev/null 2>&1; then
		dflt='/bsd43/usr/include'
		incpath='/bsd43'
		mips_type='BSD 4.3'
	else
		mips_type='System V'
	fi
	$rm -f usr.c usr.out
	echo "and you're compiling with the $mips_type compiler and libraries."
else
	echo "Doesn't look like a MIPS system."
	echo "exit 1" >mips
	chmod +x mips
	$eunicefix mips
fi
echo " "
fn=d/
rp='Where are the include files you want to use?'
. ./getfile
usrinc="$ans"

: Set private lib path
case "$plibpth" in
'') if mips; then
		plibpth="$incpath/usr/lib /usr/local/lib /usr/ccs/lib"
	else
		plibpth="/usr/ccs/lib /usr/lib /usr/ucblib /usr/local/lib"
	fi;;
esac
libpth="$plibpth $libpth"

: Looking for optional libraries
echo " "
echo "Checking for optional libraries..." >&4
case "$libs" in
' '|'') dflt='';;
*) dflt="$libs";;
esac
case "$libswanted" in
'') libswanted='c_s';;
esac
for thislib in $libswanted; do
	case "$thislib" in
	dbm) thatlib=ndbm;;
	*_s) thatlib=NONE;;
	*) thatlib="${thislib}_s";;
	*) thatlib=NONE;;
	esac
	yyy="$incpath/usr/ccs/lib $incpath/usr/lib $incpath/usr/ucblib"
	yyy="$yyy $incpath/usr/local/lib $incpath/lib"
	xxx=`loc lib$thislib.a X $yyy`
	if $test -f $xxx; then
		echo "Found -l$thislib."
		case "$dflt" in
		*-l$thislib*|*-l$thatlib*);;
		*) dflt="$dflt -l$thislib";;
		esac
	else
		xxx=`loc lib$thislib.a X $libpth`
		if $test -f $xxx; then
			echo "Found $xxx."
			case "$dflt" in
			*$xxx*);;
			*) dflt="$dflt $xxx";;
			esac
		else
			xxx=`loc Slib$thislib.a X $xlibpth`
			if $test -f $xxx; then
				echo "Found -l$thislib."
				case "$dflt" in
				*-l$thislib*|*-l$thatlib*);;
				*) dflt="$dflt -l$thislib";;
				esac
			else
				echo "No -l$thislib."
			fi
		fi
	fi
done
set X $dflt
shift
dflt="$*"
case "$libs" in
'') dflt="$dflt";;
*) dflt="$libs";;
esac
case "$dflt" in
' '|'') dflt='none';;
esac

$cat <<EOM
 
Some versions of Unix support shared libraries, which make executables smaller
but make load time slightly longer.

On some systems, mostly newer Unix System V's, the shared library is included
by putting the option "-lc_s" as the last thing on the cc command line when
linking.  Other systems use shared libraries by default.  There may be other
libraries needed to compile $package on your machine as well.  If your system
needs the "-lc_s" option, include it here.  Include any other special libraries
here as well.  Say "none" for none.
EOM

echo " "
rp="Any additional libraries?"
. ./myread
case "$ans" in
none) ans=' ';
esac
libs="$ans"

usenm=true
runnm=$usenm
case "$reuseval" in
true) runnm=false;;
esac

: nm options which may be necessary
case "$nm_opt" in
'') if $test -f /mach_boot; then
		nm_opt=''
	elif $test -d /usr/ccs/lib; then
		nm_opt='-p'
	elif $test -f /dgux; then
		nm_opt='-p'
	else
		nm_opt=''
	fi;;
esac

case "$runnm" in
true)
: get list of predefined functions in a handy place
echo " "
case "$libc" in
'') libc=unknown
	case "$libs" in
	*-lc_s*) libc=`loc libc_s.a $libc $libpth`
	esac
	;;
esac
libpth="$plibpth $libpth"
libnames='';
case "$libs" in
'') ;;
*)  for thislib in $libs; do
	case "$thislib" in
	-l*)
		thislib=`expr X$thislib : 'X-l\(.*\)'`
		try=`loc lib$thislib.a blurfl/dyick $libpth`
		if test ! -f $try; then
			try=`loc lib$thislib blurfl/dyick $libpth`
			if test ! -f $try; then
				try=`loc $thislib blurfl/dyick $libpth`
				if test ! -f $try; then
					try=`loc Slib$thislib.a blurfl/dyick $xlibpth`
					if test ! -f $try; then
						try=''
					fi
				fi
			fi
		fi
		libnames="$libnames $try"
		;;
	*) libnames="$libnames $thislib" ;;
	esac
	done
	;;
esac
case "$libc" in
unknown)
	set /usr/ccs/lib/libc.so
	$test -r $1 || set /usr/lib/libc.so
	$test -r $1 || set /usr/lib/libc.so.[0-9]*
	$test -r $1 || set /lib/libsys_s.a
	eval set \$$#
	;;
*)
	set blurfl
	;;
esac
apollo='false'
if $test -r "$1"; then
	echo "Your (shared) C library seems to be in $1."
	libc="$1"
elif $test -r /lib/libc && $test -r /lib/clib; then
	echo "Your C library seems to be in both /lib/clib and /lib/libc."
	libc='/lib/clib /lib/libc'
	if $test -r /lib/syslib; then
		echo "(Your math library is in /lib/syslib.)"
		libc="$libc /lib/syslib"
	fi
	apollo='true'
elif $test -r "$libc" || (test -h "$libc") >/dev/null 2>&1; then
	echo "Your C library seems to be in $libc, as you said before."
elif $test -r $incpath/usr/lib/libc.a; then
	libc=$incpath/usr/lib/libc.a;
	echo "Your C library seems to be in $libc.  That's fine."
elif $test -r /lib/libc.a; then
	libc=/lib/libc.a;
	echo "Your C library seems to be in $libc.  You're normal."
else
	if ans=`./loc libc.a blurfl/dyick $libpth`; $test -r "$ans"; then
		:
	elif ans=`./loc libc blurfl/dyick $libpth`; $test -r "$ans"; then
		libnames="$libnames "`./loc clib blurfl/dyick $libpth`
	elif ans=`./loc clib blurfl/dyick $libpth`; $test -r "$ans"; then
		:
	elif ans=`./loc Slibc.a blurfl/dyick $xlibpth`; $test -r "$ans"; then
		:
	elif ans=`./loc Mlibc.a blurfl/dyick $xlibpth`; $test -r "$ans"; then
		:
	else
		ans=`./loc Llibc.a blurfl/dyick $xlibpth`
	fi
	if $test -r "$ans"; then
		echo "Your C library seems to be in $ans, of all places."
		libc=$ans
	else
		libc='blurfl'
	fi
fi
if $test "$apollo" = 'false'; then
	if $test -r "$libc" || (test -h "$libc") >/dev/null 2>&1; then
		dflt="$libc"
		cat <<EOM

If the guess above is wrong (which it might be if you're using a strange
compiler, or your machine supports multiple models), you can override it here.

EOM
	else
		dflt=''
		echo $libpth | tr ' ' '\012' | sort | uniq > libpath
		cat >&4 <<EOM
I can't seem to find your C library.  I've looked in the following places:

EOM
		$sed 's/^/	/' libpath
		cat <<EOM

None of these seems to contain your C library. I need to get its name...

EOM
	fi
	fn=f
	rp='Where is your C library?'
	. ./getfile
	libc="$ans"
fi

echo " "
echo $libc $libnames | tr ' ' '\012' | sort | uniq > libnames
set X `cat libnames`
shift
xxx=files
case $# in 1) xxx=file; esac
echo "Extracting names from the following $xxx for later perusal:" >&4
echo " "
$sed 's/^/	/' libnames >&4
echo " "
$echo $n "This may take a while...$c" >&4

nm $nm_opt $* 2>/dev/null >libc.tmp
$echo $n ".$c"
$grep fprintf libc.tmp > libc.ptf
xscan='eval "<libc.ptf $com >libc.list"; $echo $n ".$c" >&4'
xrun='eval "<libc.tmp $com >libc.list"; echo "done" >&4'
if com="$sed -n -e 's/^.* [ADTS]  *_[_.]*//p' -e 's/^.* [ADTS] //p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^__*//' -e 's/^\([a-zA-Z_0-9$]*\).*xtern.*/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e '/|UNDEF/d' -e '/FUNC..GL/s/^.*|__*//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^.* D __*//p' -e 's/^.* D //p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^_//' -e 's/^\([a-zA-Z_0-9]*\).*xtern.*text.*/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^.*|FUNC |GLOB .*|//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$grep '|' | $sed -n -e '/|COMMON/d' -e '/|DATA/d' \
				-e '/ file/d' -e 's/^\([^ 	]*\).*/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^.*|FUNC |GLOB .*|//p' -e 's/^.*|FUNC |WEAK .*|//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^__//' -e '/|Undef/d' -e '/|Proc/s/ .*//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
else
	nm -p $* 2>/dev/null >libc.tmp
	com="$sed -n -e 's/^.* [ADTS]  *_[_.]*//p' -e 's/^.* [ADTS] //p'";\
	eval "<libc.tmp $com >libc.list"
	if $contains '^fprintf$' libc.list >/dev/null 2>&1; then
		nm_opt='-p'
		echo "done" >&4
	else
		echo " "
		echo "nm didn't seem to work right. Trying ar instead..." >&4
		com=''
		if ar t $libc > libc.tmp; then
			for thisname in $libnames; do
				ar t $thisname >>libc.tmp
			done
			$sed -e 's/\.o$//' < libc.tmp > libc.list
			echo "Ok." >&4
		else
			echo "ar didn't seem to work right." >&4
			echo "Maybe this is a Cray...trying bld instead..." >&4
			if bld t $libc | $sed -e 's/.*\///' -e 's/\.o:.*$//' > libc.list; then
				for thisname in $libnames; do
					bld t $libnames | \
					$sed -e 's/.*\///' -e 's/\.o:.*$//' >>libc.list
					ar t $thisname >>libc.tmp
				done
				echo "Ok." >&4
			else
				echo "That didn't work either.  Giving up." >&4
				exit 1
			fi
		fi
	fi
fi
nm_extract="$com"
if $test -f /lib/syscalls.exp; then
	echo " "
	echo "Also extracting names from /lib/syscalls.exp for good ole AIX..." >&4
	$sed -n 's/^\([^ 	]*\)[ 	]*syscall$/\1/p' /lib/syscalls.exp >>libc.list
fi
;;
esac
$rm -f libnames libpath

: determine optimize, if desired, or use for debug flag also
case "$optimize" in
' ') dflt="none";;
'') dflt="-O";;
*) dflt="$optimize";;
esac
$cat <<EOH

Some C compilers have problems with their optimizers, by default, $package
compiles with the -O flag to use the optimizer.  Alternately, you might want
to use the symbolic debugger, which uses the -g flag (on traditional Unix
systems).  Either flag can be specified here. To use neither flag, specify
the word "none".

EOH
rp="What optimizer/debugger flag should be used?"
. ./myread
optimize="$ans"
case "$optimize" in
'none') optimize=" ";;
esac

case "$ccflags" in
'')	case "$cc" in
	*gcc*) dflt='-fpcc-struct-return';;
	*) dflt='';;
	esac
	case "$optimize" in
	*-g*) dflt="$dflt -DDEBUG";;
	esac
	;;
*) dflt="$ccflags" ;;
esac

case "$mips_type" in
*BSD*) ;;
'') ;;
*) inclwanted="$inclwanted $usrinc/bsd";;
esac
for thisincl in $inclwanted; do
	if $test -d $thisincl; then
		if $test x$thisincl != x$usrinc; then
			case "$dflt" in
			*$thisincl*);;
			*) dflt="$dflt -I$thisincl";;
			esac
		fi
	fi
done

inctest='if $contains $2 $usrinc/$1 >/dev/null 2>&1; then
	xxx=true;
elif $contains $2 $usrinc/sys/$1 >/dev/null 2>&1; then
	xxx=true;
else
	xxx=false;
fi;
if $xxx; then
	case "$dflt" in
	*$2*);;
	*) dflt="$dflt -D$2";;
	esac;
fi'

set signal.h LANGUAGE_C; eval $inctest
set signal.h NO_PROTOTYPE; eval $inctest
set signal.h _NO_PROTO; eval $inctest

case "$dflt" in
'') dflt=none;;
esac
$cat <<EOH

Your C compiler may want other flags.  For this question you should include
-I/whatever and -DWHATEVER flags and any other flags used by the C compiler,
but you should NOT include libraries or ld flags like -lwhatever.  To use no
flags, specify the word "none".

EOH
set X $dflt
shift
dflt=${1+"$@"}
rp="Any additional cc flags?"
. ./myread
case "$ans" in
none) ans='';
esac
ccflags="$ans"

: the following weeds options from ccflags that are of no interest to cpp
cppflags="$ccflags"
case "$cc" in
*gcc*) cppflags="$cppflags -D__GNUC__";;
esac
case "$mips_type" in
'');;
*BSD*) cppflags="$cppflags -DSYSTYPE_BSD43";;
esac
case "$cppflags" in
'');;
*)  set X $cppflags
	cppflags=''
	for flag
	do
		case $flag in
		-D*|-I*|-traditional|-ansi|-nostdinc) cppflags="$cppflags $flag";;
		esac
	done
	;;
esac

: flags used in final linking phase
case "$ldflags" in
'') if venix; then
		dflt='-i -z'
	else
		dflt='none'
	fi
	;;
*) dflt="$ldflags";;
esac
echo " "
rp="Any additional ld flags (NOT including libraries)?"
. ./myread
case "$ans" in
none) ans='';
esac
ldflags="$ans"
rmlist="$rmlist pdp11"

: is a C symbol defined?
csym='tlook=$1;
case "$3" in
-v) tf=libc.tmp; tc=""; tdc="";;
-a) tf=libc.tmp; tc="[0]"; tdc=[];;
*) tlook="^$1\$"; tf=libc.list; tc="()"; tdc="()";;
esac;
tx=yes;
case "$reuseval-$4" in
true-) ;;
true-*) tx=no; eval "tval=\$$4"; case "$tval" in "") tx=yes;; esac;;
esac;
case "$tx" in
yes)
	case "$runnm" in
	true)
		if $contains $tlook $tf >/dev/null 2>&1;
		then tval=true;
		else tval=false;
		fi;;
	*)
		echo "main() { extern int $1$tdc; printf(\"%d\", $1$tc); }" > t.c;
		if $cc $ccflags -o t t.c $libs >/dev/null 2>&1;
		then tval=true;
		else tval=false;
		fi;
		$rm -f t t.c;;
	esac;;
*)
	case "$tval" in
	$define) tval=true;;
	*) tval=false;;
	esac;;
esac;
eval "$2=$tval"'

: set up the script used to warn in case of inconsistency
cat <<'EOSC' >whoa
dflt=y
echo " "
echo "*** WHOA THERE!!! ***" >&4
echo "    The $hint value for \$$var on this machine was \"$was\"!" >&4
rp="    Keep the $hint value?"
. ./myread
case "$ans" in
y) td=$was; tu=$was;;
esac
EOSC

: define an is-in-libc? function
inlibc='echo " "; td=$define; tu=$undef;
sym=$1; var=$2; eval "was=\$$2";
tx=yes;
case "$reuseval$was" in
true) ;;
true*) tx=no;;
esac;
case "$tx" in
yes)
	set $sym tres -f;
	eval $csym;
	case "$tres" in
	true)
		echo "$sym() found." >&4;
		case "$was" in $undef) . whoa; esac; eval "$var=\$td";;
	*)
		echo "$sym() NOT found." >&4;
		case "$was" in $define) . whoa; esac; eval "$var=\$tu";;
	esac;;
*)
	case "$was" in
	$define) echo "$sym() found." >&4;;
	*) echo "$sym() NOT found." >&4;;
	esac;;
esac'

: see if bcmp exists
case "$d_bcmp" in
$define) d_bcmp="$undef";;
$undef) d_bcmp="$define";;
esac
set bcmp d_bcmp
eval $inlibc
case "$d_bcmp" in
$define) d_bcmp="$undef";;
*) d_bcmp="$define";;
esac

: see if bcopy exists
case "$d_bcopy" in
$define) d_bcopy="$undef";;
$undef) d_bcopy="$define";;
esac
set bcopy d_bcopy
eval $inlibc
case "$d_bcopy" in
$define) d_bcopy="$undef";;
*) d_bcopy="$define";;
esac

: find out how to find out full name
case "$d_berknames" in
"$define")
	dflt=y;;
"$undef")
	dflt=n;;
*)
	if bsd; then
		dflt=y
	elif xenix; then
		dflt=y
	else
		dflt=n
	fi
	;;
esac
$cat <<'EOM'

Does your /etc/passwd file keep full names in Berkeley/V7 format (name first
thing after ':' in GCOS field)?  In that case, a typical entry in the password
file looks like this:

    guest:**paswword**:10:100:Mister Guest User:/usr/users:/bin/sh
                              ^^^^^^^^^^^^^^^^^
EOM
rp="Berkeley/V7 format for full name in /etc/password?"
. ./myread
case "$ans" in
y*) d_passnames="$define"
	d_berknames="$define"
	d_usgnames="$undef"
	nametype=bsd
	;;
*)
	case "$d_usgnames" in
	"$define") dflt=y;;
	"$undef") dflt=n;;
	*)
		if usg; then
			dflt=y
		else
			dflt=n
		fi
		;;
	esac
$cat <<'EOM'

Does your passwd file keep full names in USG format (name sandwiched between a
'-' and a '(')?  In that case, a typical entry in the password file looks like
this:

    guest:**paswword**:10:100:000-Mister Guest User(000):/usr/users:/bin/sh
                                  ^^^^^^^^^^^^^^^^^
EOM
	rp="USG format for full name in /etc/passwd?"
	. ./myread
	case "$ans" in
	n*) echo "Full name will be taken from ~/.fullname"
		d_passnames="$undef"
		d_berknames="$undef"
		d_usgnames="$undef"
		nametype=other
		;;
	*)
		d_passnames="$define"
		d_berknames="$undef"
		d_usgnames="$define"
		nametype=usg
		;;
	esac;;
esac

: see if we have to deal with yellow pages
if $test -d /usr/etc/yp || $test -d /etc/yp; then
	echo " "
	if $test -f /usr/etc/nibindd; then
		echo "I'm fairly confident you're on a NeXT."
		echo " "
		rp='Do you get the passwd file via NetInfo?'
		dflt=y
		case "$passcat" in
		nidump*) ;;
		'') ;;
		*) dflt=n;;
		esac
		. ./myread
		case "$ans" in
		y*) passcat='nidump passwd .';;
		*) echo "You told me, so don't blame me."; echo " "; passcat='';;
		esac
	fi
	case "$passcat" in
	nidump*) ;;
	*)
		case "$passcat" in
		*ypcat*) dflt=y;;
		*) if $contains '^\+:' /etc/passwd >/dev/null 2>&1; then
				dflt=y
			else
				dflt=n
			fi;;
		esac
		rp='Are you getting the passwd file via yellow pages?'
		. ./myread
		case "$ans" in
		y*) passcat='ypcat passwd';;
		*) passcat='cat /etc/passwd';;
		esac
		;;
	esac
else
	passcat='cat /etc/passwd'
fi

: see if bzero exists
case "$d_bzero" in
$define) d_bzero="$undef";;
$undef) d_bzero="$define";;
esac
set bzero d_bzero
eval $inlibc
case "$d_bzero" in
$define) d_bzero="$undef";;
*) d_bzero="$define";;
esac

: function used to set $1 to $val
setvar='var=$1; eval "was=\$$1"; td=$define; tu=$undef;
case "$val$was" in
$define$undef) . whoa; eval "$var=\$td";;
$undef$define) . whoa; eval "$var=\$tu";;
*) eval "$var=$val";;
esac'

: see if ftime exists
set ftime d_ftime 
eval $inlibc

: see if getwd or getcwd exists
set getwd d_getwd; eval $inlibc
case "$d_getwd" in
$define) val=$undef; set d_getcwd; eval $setvar ;;
*) set getcwd d_getcwd; eval $inlibc ;;
esac

: now get the host name that appears in news articles
$echo " "
$echo "Figuring out local host name..."
cont=true
$echo 'Maybe "hostname" will work...'
if ans=`sh -c hostname 2>&1` ; then
	thishost=$ans
	phostcmd=hostname
	cont=''
fi
if $test "$cont"; then
	if xenix; then
		$echo 'Oh, dear.  Maybe "/etc/systemid" is the key...'
		if ans=`cat /etc/systemid 2>&1` ; then
			thishost=$ans
			phostcmd='cat /etc/systemid'
			$echo "Whadyaknow.  Xenix always was a bit strange..."
			cont=''
		fi
	elif $test -r /etc/systemid; then
		$echo "(What is a non-Xenix system doing with /etc/systemid?)"
	fi
fi
if $test "$cont"; then
	$echo 'No, maybe "uuname -l" will work...'
	if ans=`sh -c 'uuname -l' 2>&1` ; then
		thishost=$ans
		phostcmd='uuname -l'
	else
		$echo 'Strange.  Maybe "uname -n" will work...'
		if ans=`sh -c 'uname -n' 2>&1` ; then
			thishost=$ans
			phostcmd='uname -n'
		else
			$echo 'Oh well, maybe I can mine it out of whoami.h...'
			if ans=`sh -c $contains' sysname $usrinclude/whoami.h' 2>&1` ; then
				thishost=`$echo "$ans" | $sed 's/^.*"\(.*\)"/\1/'`
				phostcmd="sed -n -e '"'/sysname/s/^.*\"\\(.*\\)\"/\1/{'"' -e p -e q -e '}' <$usrinclude/whoami.h"
			else
				phostcmd=''
				case "$phost" in
				'') $echo "Does this machine have an identity crisis or something?" ;;
				*)  $echo "Well, you said $phost before..."
				    thishost=$phost
				    ;;
				esac
			fi
		fi
	fi
fi
: you do not want to know about this
set $thishost
thishost=$1

: translate upper to lower if necessary
case "$thishost" in
*[A-Z]*) thishost=`$echo $thishost | tr '[A-Z]' '[a-z]'`
	 ;;
esac
case "$phost" in
'')	dflt="$thishost"
	case "$dflt" in
	*.*) ;;
	*) dflt="$dflt.UUCP";;
	esac
	;;
*) dflt="$phost";;
esac
case "$thishost" in
*.*)	thishost=`$expr "X$thishost" : "X\([^.]*\)\."`;;
esac
$cat <<EOM

Trn wants to know what hostname your news software (usually inews) puts
into the "From" line of news articles posted from this machine.  If you
get this wrong the ownership checks done for Cancel, Supersede and
auto-post-selection (the -p option) will fail to recognize articles as
belonging to the poster.

(NOTE: trn does NOT create "From" lines when posting news or sending mail
as this is the job of your news/mail software, not trn.)

If you enter a filename here (by starting the name with '/' or '~') trn
will read the hostname from a file, otherwise specify as much of the
hostname as you want to be matched in the aforementioned comparisons.
If your response contains the current machine's name ($thishost) trn
will determine that portion at run-time.

EOM
rp="What hostname appears in the From line of this machine's postings?"
. ./myread
ans=`./filexp "$ans"`
case $ans in
/*)
    $echo "Trn will read the host name from $ans."
    if $test ! -f $ans ; then
	$echo "(You'll need to create $ans before trn will work.)"
    fi
    phost="$ans"
    phostcmd=''
    ;;
$thishost.*)
    phost="$ans"
    $echo "Using a dynamic host name."
    ;;
*)
    phost="$ans"
    phostcmd=''
    $echo "Using a static host name."
    ;;
esac

: see how we will look up host name
echo " "
if $test "X$phostcmd" = "X"; then
	: host name is static or a file
	d_gethname=''
	d_uname=''
elif set gethostname val -f d_gethname; eval $csym; $val; then
	echo 'gethostname() found.' >&4
	d_gethname="$define"
	ans=gethostname
elif set uname val -f d_uname; eval $csym; $val; then
	if xenix; then
		$cat <<'EOM'
uname() was found, but you're running xenix, and older versions of xenix
have a broken uname(). If you don't really know whether your xenix is old
enough to have a broken system call, use the default answer.

EOM
		dflt=y
		case "$d_uname" in
		"$define") dflt=n;;
		esac
		rp='Is your uname() broken?'
		. ./myread
		case "$ans" in
		n*) d_uname="$define"; ans=uname;;
		esac
	else
		echo 'uname() found.' >&4
		d_uname="$define"
		ans=uname
	fi
fi
case "$d_gethname" in
'') d_gethname="$undef";;
esac
case "$d_uname" in
'') d_uname="$undef";;
esac
case "$phostcmd" in
'') aphostcmd='';;
*) case "$aphostcmd" in
	/*) ;;
	*) set X $phostcmd
		shift
		file=$1
		shift
		file=`loc $file $file $pth`
		aphostcmd=`echo $file $*`
		;;
	esac
	;;
esac
case "$d_uname$d_gethname" in
*define*) ;;
*)
	case "$phostcmd" in
	'') ;;
	*)
		$cat <<EOT

There is no gethostname() or uname() on this system.  You have two
possibilities at this point:

1)  You can have the hostname in postings ($phost) compiled into trn, which
    lets trn start up faster, but makes your binaries non-portable, or
2)  you can have trn use a
	
	popen("$aphostcmd","r")

    which will start slower but be more portable.

If you want option 2 but with a different command, you can edit config.sh at
the end of this shell script.

EOT
		case "$d_phostcmd" in
		"$define") dflt=n;;
		"$undef")  dflt=y;;
		'')
			case "$d_portable" in
			"$define") dflt=n ;;
			*) dflt=y ;;
			esac;;
		esac
		rp="Do you want your host name compiled in?"
		. ./myread
		case "$ans" in
		n*) ;;
		*) aphostcmd='';;
		esac;;
	esac;;
esac
case "$aphostcmd" in
'') d_phostcmd="$undef";;
*) d_phostcmd="$define";;
esac

: see if there is a getpwent
echo " "
if set getpwent val -f d_getpwent; eval $csym; $val; then
	echo "getpwent() found." >&4
	val="$define"
else
	echo "No getpwent() found -- will use getpw() instead." >&4
	val="$undef"
fi
set d_getpwent
eval $setvar

: where do we get termlib routines from
echo " "
ans=`./loc libcurses.a x $libpth`
case "$ans" in
/*)
	ar t $ans >grimble
	if $contains tputs.o grimble >/dev/null 2>&1; then
		termlib='-lcurses'
		d_havetlib="$define"
		echo "Terminfo library found." >&4
	else
		ans=x
	fi
	rm -f grimble
	;;
esac
case "$ans" in
x)
	ans=`loc libtermlib.a x $libpth`
	case "$ans" in
	/usr/lib*|/lib*)
		termlib='-ltermlib'
		d_havetlib="$define"
		echo "Termlib library found." >&4
		;;
	/*)
		termlib="$ans"
		d_havetlib="$define"
		echo "Termlib library found." >&4
		;;
	*)
		ans=`loc libtermcap.a x $libpth`
		case "$ans" in
		/usr/lib*|/lib*)
			termlib='-ltermcap'
			d_havetlib="$define"
			echo "Termcap library found." >&4
			;;
		/*)
			termlib="$ans"
			d_havetlib="$define"
			echo "Termcap library found." >&4
			;;
		*)
			case "$termlib" in
			'')
				dflt=y
rp="Your system appears to NOT have termlib-style routines. Is this true?"
				. ./myread
				case "$ans" in
				n*|f*) d_havetlib="$define"
					$cat <<'EOM'
Then where are the termlib-style routines kept? Specify either -llibname
or a full pathname (~name ok).

EOM
					dflt=''
					rp='Specify termlib path:'
					. ./myread
					termlib=`filexp $ans`
					;;
				*)
					d_havetlib="$undef"
					termlib=''
					echo "You will have to play around with term.c then." >&4
					;;
				esac
			echo " ";;
			*)  echo "You said termlib was $termlib before." >&4;;
			esac;;
		esac;;
	esac;;
esac

: Decide whether to ignore the ORGANIZATION environment variable
case "$d_ignoreorg" in
"$define") dflt=y ;;
*)         dflt=n ;;
esac
cat <<'EOM'

Trn normally looks in the environment variables NEWSORG and ORGANIZATION
for an overriding organization name.  However, if your operating system
reserves the environment variable ORGANIZATION for other purposes, you
will want to ignore it and only have trn check for NEWSORG.

EOM
rp='Should trn ignore ORGANIZATION?'
. ./myread
case "$ans" in
y*) d_ignoreorg="$define" ;;
*)  d_ignoreorg="$undef" ;;
esac

: determine the name of a reasonable mailer
case "$mailer" in
'')
	if $test -f "$sendmail"; then
		dflt="$sendmail"
	elif $test -f "$smail"; then
		dflt="$smail"
	elif $test -f "$rmail"; then
		dflt="$rmail"
	elif $test -f /bin/mail; then
		dflt=/bin/mail
	else
		dflt=$mail
	fi
	;;
*)  dflt="$mailer";;
esac
$cat <<EOM

I need the full pathname of the program used to deliver mail on your system.
A typical answer would be /usr/lib/sendmail or /bin/rmail, but you may choose
any other program, as long as $package can feed its standard input and it
will honour any user-supplied headers.

EOM
fn=f
rp='Mail transport agent to be used?'
. ./getfile
mailer="$ans"

: check for internet mailer
case "$d_internet" in
"$undef") dflt=n;;
*)	  dflt=y;;
esac
cat <<EOM
 
Most mailers can deliver mail to addresses of the INTERNET persuasion,
such as user@host.edu.  Some older mailers, however, require the complete
path to the destination to be specified in the address.

EOM
rp="Does your mailer understand INTERNET addresses?"
. ./myread
case "$ans" in
y*) val="$define";;
*)  val="$undef";;
esac
set d_internet
eval $setvar

: see how we invoke the C preprocessor
echo " "
echo "Now, how can we feed standard input to your C preprocessor..." >&4
cat <<'EOT' >testcpp.c
#define ABC abc
#define XYZ xyz
ABC.XYZ
EOT
cd ..
echo 'cat >.$$.c; '"$cc"' -E ${1+"$@"} .$$.c; rm .$$.c' >cppstdin
chmod 755 cppstdin
wrapper=`pwd`/cppstdin
cd UU
if $test "X$cppstdin" != "X" && \
	$cppstdin $cppminus <testcpp.c >testcpp.out 2>&1 && \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "You used to use $cppstdin $cppminus so we'll use that again."
elif $test "$cc" = gcc && \
	(echo "Using gcc, eh?  We'll try to force gcc -E using a wrapper..."; \
	$wrapper <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1) ; then
	echo "Yup, we can."
	cppstdin="$wrapper"
	cppminus='';
elif echo 'Maybe "'"$cc"' -E" will work...'; \
	$cc -E <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Yup, it does."
	cppstdin="$cc -E"
	cppminus='';
elif echo 'Nope...maybe "'"$cc"' -E -" will work...'; \
	$cc -E - <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Yup, it does."
	cppstdin="$cc -E"
	cppminus='-';
elif echo 'Uh-uh.  Time to get fancy.  Trying a wrapper...'; \
	$wrapper <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	cppstdin="$wrapper"
	cppminus=''
	echo "Eureka!"
elif echo 'No such luck, maybe "'$cpp'" will work...'; \
	$cpp <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "It works!"
	cppstdin="$cpp"
	cppminus='';
elif echo 'Nixed again...maybe "'$cpp' -" will work...'; \
	$cpp - <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Hooray, it works!  I was beginning to wonder."
	cppstdin="$cpp"
	cppminus='-';
elif echo 'Nope...maybe "'"$cc"' -P" will work...'; \
	$cc -P <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Yipee, that works!"
	cppstdin="$cc -P"
	cppminus='';
elif echo 'Nope...maybe "'"$cc"' -P -" will work...'; \
	$cc -P - <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "At long last!"
	cppstdin="$cc -P"
	cppminus='-';
else
	dflt=''
	rp="No dice.  I can't find a C preprocessor.  Name one:"
	. ./myread
	cppstdin="$ans"
	$cppstdin <testcpp.c >testcpp.out 2>&1
	if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
		echo "OK, that will do." >&4
	else
echo "Sorry, I can't get that to work.  Go find one and rerun Configure." >&4
		exit 1
	fi
fi
$rm -f testcpp.c testcpp.out

: determine filename position in cpp output
echo " "
echo "Computing filename position in cpp output for #include directives..." >&4
echo '#include <stdio.h>' > foo.c
$cat >fieldn <<EOF
$startsh
$cppstdin $cppminus $cppflags <foo.c 2>/dev/null | \
$grep '^[ 	]*#.*stdio\.h' | \
while read cline; do
	pos=1
	set \$cline
	while $test \$# -gt 0; do
		if $test -r \`echo \$1 | $tr -d '"'\`; then
			echo "\$pos"
			exit 0
		fi
		shift
		pos=\`expr \$pos + 1\`
	done
done
EOF
chmod +x fieldn
fieldn=`./fieldn`
$rm -f foo.c fieldn
case $fieldn in
'') pos='???';;
1) pos=first;;
2) pos=second;;
3) pos=third;;
*) pos="${fieldn}th";;
esac
echo "Your cpp writes the filename in the $pos field of the line."

: locate header file
$cat >findhdr <<EOF
$startsh
wanted=\$1
name=''
if test -f $usrinc/\$wanted; then
	echo "$usrinc/\$wanted"
	exit 0
fi
awkprg='{ print \$$fieldn }'
echo "#include <\$wanted>" > foo\$\$.c
$cppstdin $cppminus $cppflags < foo\$\$.c 2>/dev/null | \
$grep "^[ 	]*#.*\$wanted" | \
while read cline; do
	name=\`echo \$cline | $awk "\$awkprg" | $tr -d '"'\`
	case "\$name" in
	*/\$wanted) echo "\$name"; exit 0;;
	*) name='';;
	esac;
done;
$rm -f foo\$\$.c;
case "\$name" in
'') exit 1;;
esac
EOF
chmod +x findhdr

: see if there are directory access routines out there
echo " "
if $test `./findhdr ndir.h` && \
	  ( $test -r /usr/lib/libndir.a || $test -r /usr/local/lib/libndir.a ); then
	echo "Ndir library found." >&4
	if $test -r /usr/lib/libndir.a; then
		libndir='-lndir'
	else
		libndir="/usr/local/lib/libndir.a"
	fi
	d_libndir="$define"
	d_usendir="$undef"
	ndirc=''
	ndiro=''
else
	libndir=''
	d_libndir="$undef"
	if set readdir val -f; eval $csym; $val; then
	echo "No ndir library found, but you have readdir() so we'll use that." >&4
		d_usendir="$undef"
		ndirc=''
		ndiro=''
	else
		echo "No ndir library found--using ./ndir.c." >&4
		d_usendir="$define"
		ndirc='ndir.c'
		ndiro='ndir.o'
	fi
fi

: get news administrator name
case "$newsadmin" in
'')
	if $contains "^news:" /etc/passwd >/dev/null 2>&1 ; then
		dflt=news
	elif $contains "^usenet:" /etc/passwd >/dev/null 2>&1 ; then
		dflt=usenet
	elif eunice; then
		dflt=system
	else
		dflt=root
	fi
	;;
*)
	dflt="$newsadmin"
	;;
esac
$cat <<'EOM'
 
Many systems keep their news in a private directory, or have a non-superuser
in charge of administering news.  (If you don't have such a user, take the
default answer.)  I need the login name (not directory) which is used for
news administration.

EOM
rp="News admin login?"
. ./myread
newsadmin="$ans"
case "$newsadmin" in
root) val="$undef" ;;
*) val="$define" ;;
esac
set d_newsadm
eval $setvar

: check for buffering of stdout
echo " "
case "$d_nolnbuf" in
'')
	$cat <<'EOT' >blurfl.c
#include <stdio.h>
main()
{
	int i;

	for (i = 0; i < 5; i++) {
		putchar(i+'a');
		sleep(1);
	}
	putchar('\n');
}
EOT
	$cc blurfl.c -o blurfl >/dev/null 2>&1;
	$rm -f blurfl.c
	$cat >&4 <<'EOM'
Checking for buffering of stdout to terminal.

Observe the following characters as they are printed out, to see whether they
print out all at once, or with a 1 second pause between each of them.  If they
print out one by one, you don't have buffering.  If they print together (after
about a 5 second pause), you do have buffering.

EOM
	dflt=''
	rp="Type return to start printing the test characters:"
	. ./myread
	ans=y
	while $test "$ans" = 'y'; do
		blurfl 1>&4
		dflt=n
		rp='Would you like to see that again?'
		. ./myread
	done
		dflt=y
		rp="Do you have buffering (printed all at once)?"
		. ./myread
		case "$ans" in
		n*) val="$define";;
		*)  val="$undef";;
		esac
		;;
*)
	case "$d_nolnbuf" in
	"$define") dflt=n;;
	*) dflt=y;;
	esac
	rp="Do you have buffering on stdout to terminals?"
	. ./myread
	case "$ans" in
	n*) val="$define";;
	*)  val="$undef";;
	esac
	;;
esac
set d_nolnbuf
eval $setvar

: see if we need -ljobs and if we have sigset, etc.
echo " "
if $test -r /usr/lib/libjobs.a || $test -r /usr/local/lib/libjobs.a ; then
	echo "Jobs library found." >&4
	val="$undef"
	jobslib='-ljobs'
else
	if bsd; then
		echo "No jobs library found. (I suppose this is at least 4.2...)" >&4
	else
		echo "No jobs library found. (That's okay, we all have our faults.)" >&4
	fi
	val="$define"
	jobslib=''
fi
set d_normsig
eval $setvar

: get C preprocessor symbols handy
echo " "
echo $attrlist | $tr ' ' '\012' >Cppsym.know
$cat <<EOSS >Cppsym
$startsh
case "\$1" in
-l) list=true
	shift
	;;
esac
unknown=''
case "\$list\$#" in
1|2)
	for sym do
		if $contains "^\$1$" Cppsym.true >/dev/null 2>&1; then
			exit 0
		elif $contains "^\$1$" Cppsym.know >/dev/null 2>&1; then
			:
		else
			unknown="\$unknown \$sym"
		fi
	done
	set X \$unknown
	shift
	;;
esac
case \$# in
0) exit 1;;
esac
echo \$* | $tr ' ' '\012' | $sed -e 's/\(.*\)/\\
#ifdef \1\\
exit 0; _ _ _ _\1\\	 \1\\
#endif\\
/' >Cppsym\$\$
echo "exit 1; _ _ _" >>Cppsym\$\$
$cppstdin $cppminus <Cppsym\$\$ | $grep '^exit [01]; _ _'  >Cppsym2\$\$
case "\$list" in
true) $awk 'NF > 5 {print substr(\$6,2,100)}' <Cppsym2\$\$ ;;
*)
	sh Cppsym2\$\$
	status=\$?
	;;
esac
$rm -f Cppsym\$\$ Cppsym2\$\$
exit \$status
EOSS
chmod +x Cppsym
$eunicefix Cppsym
echo "Your C preprocessor defines the following symbols:"
Cppsym -l $attrlist >Cppsym.true
$cat Cppsym.true

: see if there is a vfork
$echo " "
if set vfork val -f d_hvfork; eval $csym; $val; then
	$echo "vfork() found." >&4
	if Cppsym sgi; then
		$echo "However, IRIX vfork() is buggy. We'll use fork() instead." >&4
		val="$define"
	else
		val="$undef"
	fi
else
	$echo "No vfork() found--will use fork() instead." >&4
	val="$define"
fi
set d_novfork
eval $setvar
case "$d_novfork" in
"$define") d_hvfork="$undef";;
*)	   d_hvfork="$define";;
esac

: check for void type
echo " "
$echo "Checking to see how well your C compiler groks the void type..."
$cat >void.c <<'EOCP'
void main();
EOCP
if $cc -c void.c >/dev/null 2>&1 ; then
    d_novoid="$undef"
    $echo "Yup, it does."
else
    d_novoid="$define"
    $echo "Nope, it doesn't (boo hiss).  I will substitute int."
fi
$rm void.*

: see if rdchk exists
set rdchk d_rdchk
eval $inlibc

: see if rename exists
set rename d_rename
eval $inlibc

: see if sigblock exists
if set sigblock val -f d_sigblock; eval $csym; $val; then
	$echo "sigblock() found." >&4
	if Cppsym sgi; then
		$echo "We'll ignore it on this Silicon Graphics box, though."
		val="$undef"
	else
		val="$define"
	fi
else
	val="$undef"
fi
set d_sigblock
eval $setvar

: see if sighold exists
set sighold d_sighold
eval $inlibc

: see if we need to define size_t
if $contains 'size_t' /usr/include/string*.h >/dev/null 2>&1 ; then
    d_sizet="$undef"
else
    d_sizet="$define"
fi

: index or strchr
$echo " "
if set index val -f; eval $csym; $val; then
	val="$undef"
	$echo "index() found." >&4
elif set strchr val -f d_strchr; eval $csym; $val; then
	val="$define"
	$echo "strchr() found." >&4
else
	$echo "No index() or strchr() found!" >&4
	val="$undef"
fi
set d_strchr
eval $setvar

: see if strftime exists
set strftime d_strftime
eval $inlibc

: locate news spool directory
if $test "X$d_nntp" = "X$define" ; then
	newsspool="/tmp"
else
	case "$newsspool" in
	'') dflt=/usr/spool/news;;
	*) dflt="$newsspool";;
	esac
	$echo " "
	fn=d~
	rp='Where is news spooled?'
	. ./getfile
	newsspool="$ans"
fi

: check on .thread/.overview file placement
case "$threaddir" in
'')	if $test "X$d_nntp" = "X$define" ; then
		dflt="/usr/spool/threads"
	else
		dflt="$newsspool"
	fi
	;;
*)	dflt="$threaddir";;
esac
case "$d_xdata" in
define) ans="/tmp";;
*)	$echo " "
	$echo "Trn needs to know the base directory for the .thread or .overview files"
	$echo "on your system.  Answer 'none' if there won't be any."
	rp="Where do .thread/.overview files reside?"
	. ./myread
	;;
esac
threaddir="$ans"
overviewdir="$ans"
if $test "X$ans" = "X$none" ; then
    d_useov=undef
    d_usemt=undef
else
    d_useov=define
    d_usemt=define
fi

: preserve RCS keywords in files with variable substitution, grrr
Id='$Id'
Log='$Log'

: determine where public executables go
$echo " "
case "$bin" in
'') dflt=`./loc . /usr/local/bin /usr/local/bin /usr/lbin /usr/local /usr/bin /bin` ;;
*)  dflt="$bin" ;;
esac
fn=d~
rp='Pathname where the public executables will reside?'
. ./getfile
if $test "X$bin" != "X$ans"; then
	installbin=''
fi
bin="$ans"

case "$installbin" in
'') dflt=`echo $bin | sed 's#^/afs/#/afs/.#'` ;;
*)  dflt="$installbin" ;;
esac
$cat <<EOM

To install the files in this directory, a few strange systems need
to use a different directory name to get the files there.

EOM
rp='What directory name should be used for the install?'
. ./getfile
installbin="$ans"

: get the local distributions
$cat <<'EOH'
 
Distribution groups are the things you use on the Distribution line to limit
where an article will go to.  You are likely to be a member of several
distribution groups, such as organization, city, state, province, country,
continent, etc.  For example, Los Angeles has the distribution code "la",
New Jersey has the code "nj", and Europe has the code "eunet".

The categories you will be asked are: 

local organization	(Could be just one machine or a cluster or an office)
organization		att, dec, kgb, ...
city			la, ny, mosc, ...
state/province		ca, nj, bc, ...
country			usa, can, rok, whatever
continent		na (North America), asia, etc.

EOH
if $test -f $newslibexp/distributions; then
	case "$silent" in
	true) ;;
	*)	dflt='Hit return to continue'
		rp=''
		. ./myread
		;;
	esac
	$echo "Here is your distributions file:" >&4
	$echo " " >&4
	$cat >&4 $newslibexp/distributions
	$echo " " >&4
fi
$echo "Use 'none' for any distributions you don't have."
$echo " "
case "$locdist" in
'') dflt="none";;
*)  dflt="$locdist";;
esac
rp="What is the distribution code for your local organization?"
. ./myread
locdist="$ans"
case "$orgdist" in
'') dflt="none";;
*)  dflt="$orgdist";;
esac
rp="What is the distribution code for your organization?"
. ./myread
orgdist="$ans"
case "$citydist" in
'') dflt="none";;
*)  dflt="$citydist";;
esac
rp="What is the distribution code for your city?"
. ./myread
citydist="$ans"
case "$statedist" in
'') dflt="none";;
*)  dflt="$statedist";;
esac
rp="What is the distribution code for your state/province?"
. ./myread
statedist="$ans"
case "$cntrydist" in
'') dflt="none";;
*)  dflt="$cntrydist";;
esac
rp="What is the distribution code for your country?"
. ./myread
cntrydist="$ans"
case "$contdist" in
'') dflt="none";;
*)  dflt="$contdist";;
esac
rp="What is the distribution code for your continent?"
. ./myread
contdist="$ans"
$cat <<'EOM'
  
If you have any other distribution groups you will need to edit Pnews
and newsetup to add them.
EOM

: determine default editor
case "$defeditor" in
'')
	case "$_vi" in
	*/*) dflt="$_vi";;
	*) dflt=/usr/ucb/vi;;
	esac
	;;
*)  dflt="$defeditor"
	;;
esac
$echo " "
fn=f/
rp="What is the default editor on your system?"
. ./getfile
defeditor="$ans"

: determine where private executables go
case "$privlib" in
'')	dflt=/usr/lib/$package
	$test -d /usr/local/lib && dflt=/usr/local/lib/$package ;;
*)	dflt="$privlib" ;;
esac
$cat <<EOM

There are some auxiliary files for $package that need to be put into a
private library directory that is accessible by everyone.

EOM
fn=d~+
rp='Pathname where the private library files will reside?'
. ./getfile
if $test "X$privlib" != "X$ans"; then
	installprivlib=''
fi
privlib="$ans"

case "$installprivlib" in
'') dflt=`echo $privlib | sed 's#^/afs/#/afs/.#'` ;;
*)  dflt="$installprivlib" ;;
esac
$cat <<EOM

To install the files in this directory, a few strange systems need
to use a different directory name to get the files there.

EOM
rp='What directory name should be used for the install?'
. ./getfile
installprivlib="$ans"

: must not allow self reference
case "$privlib" in
  /*)
	filexp=$privlib/filexp
	;;
  *)
	filexp=`pwd`/filexp
	;;
esac

: determine where mail is spooled
case "$mailfile" in
'')
	dflt=`./loc . XXX /usr/spool/mail /usr/mail`
	case "$dflt" in
	XXX) dflt='%~/mailbox';;
	*) dflt="$dflt/%L";;
	esac
	;;
*)  dflt="$mailfile"
	;;
esac
cat <<'EOM'

In the following question, you may use %~ to represent the user's home
directory, and %L to represent a users name.

EOM
rp='In which file is yet-to-be-read mail spooled? (~name ok)'
. ./myread
mailfile=`./filexp "$ans"`

: determine where manual pages go
$cat <<EOM

$package has manual pages available in source form.
EOM
case "$nroff" in
nroff)
	echo "However, you don't have nroff, so they're probably useless to you."
	case "$mansrc" in
	'') mansrc="none";;
	esac;;
esac
echo "If you don't want the manual sources installed, answer 'none'."
case "$mansrc" in
'')
	dflt="$sysman"
	;;
*)  dflt="$mansrc"
	;;
esac
echo " "
fn=dn~
rp='Where do the manual pages (source) go?'
. ./getfile
mansrc="$ans"
case "$mansrc" in
'') manext='0';;
*l) manext=l;;
*n) manext=n;;
*o) manext=l;;
*p) manext=n;;
*C) manext=C;;
*L) manext=L;;
*) manext=1;;
esac

: determine how to determine when a file is a mailbox
case "$mboxchar" in
'') dflt=F;;
*)  dflt="$mboxchar";;
esac
$cat <<EOM
 
In saving articles, $package wants to differentiate between saving to
mailbox format files and normal files.  It does this by examining the
first character of the file in question.  On most systems the first line
starts with "From ...", so the first character is an F. Other systems
use magic cookies like control codes between articles, so one of those
would be first.

EOM
rp="What's the first character of a mailbox file?"
. ./myread
mboxchar="$ans"
case "$mboxchar" in
'F') ;;
*)  cat <<'EOM'

You will need to edit the shell script mbox.saver to properly append an
article to a mailbox.  The arguments to the script are documented in
EOM
	case "$shsharp" in
	false) echo "comments in mbox.saver.std.";;
	true) echo "comments in the shell script itself.";;
	esac
esac

: get organization name
longshots='/usr/src/new /usr/src/local /usr/local/src'
case "$orgname" in
'') if xxx=`loc news/src/defs.h x $longshots`; then
		dflt=`$sed -n 's/^.*MYORG[ 	]*"\(.*\)".*$/\1/p' $xxx`
	else
		dflt=''
	fi
	;;
*)  dflt="$orgname";;
esac
$cat << 'EOH'
 
Please type the name of your organization as you want it to appear on the
Organization line of outgoing articles.  (It's nice if this also specifies
your location.  Your city name is probably sufficient if well known.)
For example:

    University of Southern North Dakota, Hoople

You may also put the name of a file, as long as it begins with a slash.
For example:

    /etc/organization

EOH
orgname=""
while test "X$orgname" = "X"; do
	rp='Organization:'
	. ./myread
	orgname="$ans"
done

: locate the preferred pager for this system
case "$pager" in
'')
	case "$pg" in
	/*) dflt=$pg;;
	esac
	case "$less" in
	/*) dflt=$less;;
	esac
	case "$more" in
	/*) dflt=$more;;
	esac
	case "$dflt" in
	'') dflt=/usr/ucb/more;;
	esac
	;;
*) dflt="$pager";;
esac
$cat <<EOM

Some of the support scripts want to use a paging program such as "more"
to help the user page through the generated output.  You'll probably
want the most innocuous pager you have, since some lists consist of only
one line (if your kernel does terminal paging then you may answer this
with "$cat").  Also note that this does not affect the paging of
articles, as trn uses an internal pager for that.

EOM
fn=f/
rp='What pager should we use?'
. ./getfile
pager="$ans"

: find out which shell people like to use most
case "$prefshell" in
'')
	case "$ksh $bash $csh" in
	*/ksh*) dflt="$ksh" ;;
	*/bash*) dflt="$bash" ;;
	*/csh*) dflt="$csh" ;;
	*) dflt='/bin/sh' ;;
	esac
	;;
*)  dflt="$prefshell";;
esac
$cat <<EOM

Give the full path name of the shell most people like to use on your system.
This will be used by $package whenever the user wants to get a shell
escape (for instance) and is not necessarily the same as the shell you are
currently using (${SHELL-/bin/sh}).

EOM
fn=f/~
rp='Preferred shell to be used?'
. ./getfile
prefshell=$ans

: determine root id
echo " "
rootid=`$sed -e "/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*"'$'"/\1/" -e "q" -e "}" -e "d" </etc/passwd`
case "$rootid" in
'') rootid=0 ;;
*) echo "Root uid = $rootid" >&4 ;;
esac

: see if signal is declared as pointer to function returning int or void
echo " "
xxx=`./findhdr signal.h`
$test "$xxx" && $cppstdin $cppminus $cppflags < $xxx >$$.tmp 2>/dev/null
if $contains 'int.*\*[ 	]*signal' $$.tmp >/dev/null 2>&1 ; then
	echo "You have int (*signal())() instead of void." >&4
	val="$undef"
	signal_t="int"
elif $contains 'void.*\*[ 	]*signal' $$.tmp >/dev/null 2>&1 ; then
	echo "You have void (*signal())() instead of int." >&4
	val="$define"
	signal_t="void"
elif $contains 'extern[ 	]*[(\*]*signal' $$.tmp >/dev/null 2>&1 ; then
	echo "You have int (*signal())() instead of void." >&4
	val="$undef"
	signal_t="int"
else
	case "$d_voidsig" in
	'')
	echo "I can't determine whether signal handler returns void or int..." >&4
		dflt=void
		rp="What type does your signal handler returns?"
		. ./myread
		case "$ans" in
		void) val="$define"; signal_t="void";;
		*) val="$undef"; signal_t="int";;
		esac;;
	*) echo "As you already told me, signal handler returns $signal_t." >&4;;
	esac
fi
set d_voidsig
eval $setvar
$rm -f $$.tmp

: check if they want threads by default
case "$trn_init" in
F*) dflt="n";;
*)  dflt="y";;
esac
$cat <<'EOM'

Trn has two distinct operating modes (selected by the -x option):
traditional rn and threaded rn.  If you like, trn will check the first
letter of the command name and default to threaded mode (-x) if it is
a 't', or run as traditional rn (+x) if it isn't (this lets you install
as both trn and rn, linked together).  Otherwise, you can install trn
to default to threaded rn (-x) no matter what its name is.

EOM
rp='Do you want trn to default to -x, regardless of name?'
. ./myread
case "$ans" in
n*|f*)	trn_init='FALSE'
	ans=' for trn (not rn)';;
*)	trn_init='TRUE'
	ans='';;
esac
: check if they want the selector used by default
case "$trn_select" in
F*) dflt="n";;
*)  dflt="y";;
esac
$cat <<'EOM'

When the -X option is specified, trn will set the default command
for starting a newsgroup to be the selector.

EOM
rp="Should the -X option be on by default$ans?"
. ./myread
case "$ans" in
n*|f*) trn_select=FALSE;;
*)     trn_select=TRUE;;
esac

: see if this is a dirent system
echo " "
if xinc=`./findhdr dirent.h`; $test "$xinc"; then
	val="$define"
	echo "<dirent.h> found." >&4
else
	val="$undef"
	if xinc=`./findhdr sys/dir.h`; $test "$xinc"; then
		echo "<sys/dir.h> found." >&4
		echo " "
	else
		xinc=`./findhdr sys/ndir.h`
	fi
	echo "<dirent.h> NOT found." >&4
fi
set i_dirent
eval $setvar

: Initialize h_fcntl
h_fcntl=false

: Initialize h_sysfile
h_sysfile=false

: define an alternate in-header-list? function
inhdr='echo " "; td=$define; tu=$undef; yyy=$@;
cont=true; xxf="echo \"<\$1> found.\" >&4";
case $# in 2) xxnf="echo \"<\$1> NOT found.\" >&4";;
*) xxnf="echo \"<\$1> NOT found, ...\" >&4";;
esac;
case $# in 4) instead=instead;; *) instead="at last";; esac;
while $test "$cont"; do
	xxx=`./findhdr $1`
	var=$2; eval "was=\$$2";
	if $test "$xxx" && $test -r "$xxx";
	then eval $xxf;
		eval "case \"\$$var\" in $undef) . whoa; esac"; eval "$var=\$td";
		cont="";
	else eval $xxnf;
		eval "case \"\$$var\" in $define) . whoa; esac"; eval "$var=\$tu"; fi;
	set $yyy; shift; shift; yyy=$@;
	case $# in 0) cont="";;
	2) xxf="echo \"but I found <\$1> $instead.\" >&4";
		xxnf="echo \"and I did not find <\$1> either.\" >&4";;
	*) xxf="echo \"but I found <\$1\> instead.\" >&4";
		xxnf="echo \"there is no <\$1>, ...\" >&4";;
	esac;
done;
while $test "$yyy";
do set $yyy; var=$2; eval "was=\$$2";
	eval "case \"\$$var\" in $define) . whoa; esac"; eval "$var=\$tu";
	set $yyy; shift; shift; yyy=$@;
done'

: see if fcntl.h is there
val=''
set fcntl.h val
eval $inhdr

: see if we can include fcntl.h
case "$val" in
"$define")
	echo " "
	if $h_fcntl; then
		val="$define"
		echo "We'll be including <fcntl.h>." >&4
	else
		val="$undef"
		if $h_sysfile; then
	echo "We don't need to include <fcntl.h> if we include <sys/file.h>." >&4
		else
			echo "We won't be including <fcntl.h>." >&4
		fi
	fi
	;;
*)
	h_fcntl=false
	val="$undef"
	;;
esac
set i_fcntl
eval $setvar

: see if ptem.h exists
if $test -r /usr/include/sys/ptem.h ; then
    $echo "sys/ptem.h found."
    i_ptem="$define"
else
    i_ptem="$undef"
fi

: see if this is a termio system
val="$undef"
val2="$undef"
val3="$undef"
$echo " "
if Cppsym pyr; then
	case "`bin/universe`" in
	ucb)	if $test `./findhdr sgtty.h`; then
			val2="$define"
			$echo "<sgtty.h> found." >&4
		else
			$echo "System is pyramid with BSD universe." >&4
			$echo "<sgtty.h> not found--you could have problems." >&4
		fi;;
	*)	if $test `./findhdr termio.h`; then
			val="$define"
			$echo "<termio.h> found." >&4
		else
			$echo "System is pyramid with USG universe." >&4
			$echo "<termio.h> not found--you could have problems." >&4
		fi;;
	esac
elif bsd; then
	if $test `./findhdr sgtty.h`; then
		$echo "<sgtty.h> found." >&4
		val2="$define"
	elif $test `./findhdr termio.h`; then
		$echo "<termio.h> found." >&4
		val="$define"
	else
$echo "Neither <sgtty.h> nor <termio.h> found--you could have problems." >&4
	fi
else
	if $test -d /usr/convex; then
		echo "<termios.h> found." >&4
		val3="$define"
	elif $test `./findhdr termio.h`; then
		echo "<termio.h> found." >&4
		val="$define"
	elif $test `./findhdr sgtty.h`; then
		echo "<sgtty.h> found." >&4
		val2="$define"
	else
echo "Neither <termio.h> nor <sgtty.h> found--you could have problems." >&4
	fi
fi
set i_termio; eval $setvar
val=$val2; set i_sgtty; eval $setvar
val=$val3; set i_termios; eval $setvar

: see if this is an sysdir system
set sys/dir.h i_sysdir
eval $inhdr

: see if ioctl defs are in sgtty/termio or sys/ioctl
echo " "
if $test `./findhdr sys/ioctl.h`; then
	val="$define"
	echo "<sys/ioctl.h> found." >&4
else
	val="$undef"
	$test $i_termio = "$define" && xxx="termio.h"
	$test $i_termios = "$define" && xxx="termios.h"
	$test $i_sgtty = "$define" && xxx="sgtty.h"
echo "No <sys/ioctl.h> found, assuming ioctl args are defined in <$xxx>." >&4
fi
set i_sysioctl
eval $setvar

: see if this is an sysndir system
set sys/ndir.h i_sysndir
eval $inhdr

: see if this is a vfork system
set vfork.h i_vfork
eval $inhdr

: check for ispell spelling checker
case "$ispell_path" in
none)	dflt=n
	dflt_path=
	dflt_options=
	;;
'')	if $test -n "$ispell" -a "$ispell" != "ispell"; then
	    dflt=y
	    dflt_path=$ispell
	    dflt_options='-x'
	else
	    dflt=n
	    dflt_path=
	    dflt_options=
	fi
	;;
*)	dflt=y
	dflt_path=$ispell_path
	dflt_options=$ispell_options
	;;
esac
$cat <<EOM

Pnews has a "Check spelling" option that will allow you to correct spelling
errors if you have ispell, or will simply list possible spelling errors via
spell if you don't.

EOM
if $test -n "$dflt_path"; then
	$echo "Configure has found ispell as $dflt_path"
else
	$echo "Configure was unable to find ispell"
fi
rp="Do you want to use ispell?"
. ./myread
case "$ans" in
y*)	dflt=$dflt_path
	fn=f/
	rp='What is the full pathname of the executable?'
	. ./getfile
	ispell_path=$ans
	dflt=$dflt_options
	rp="What options should be used?"
	. ./myread
	ispell_options=$ans
	;;
*)	ispell_path='none'
	;;
esac

: end of configuration questions
echo " "
echo "End of configuration questions."
echo " "

: back to where it started
if test -d ../UU; then
	mv filexp ..
	cd ..
fi

: configuration may be patched via a 'config.over' file
if $test -f config.over; then
	echo " "
	dflt=y
	rp='I see a config.over file.  Do you wish to load it?'
	. ./UU/myread
	case "$ans" in
	n*) echo "OK, I'll ignore it.";;
	*)	. ./config.over
		echo "Configuration override changes have been loaded."
		;;
	esac
fi

: create config.sh file
echo " "
echo "Creating config.sh..." >&4
cf_time=`$date 2>&1`
cf_by=`( (logname) 2>/dev/null || whoami) 2>&1`
$spitshell <<EOT >config.sh
$startsh
#
# This file was produced by running the Configure script. It holds all the
# definitions figured out by Configure. Should you modify one of these values,
# do not forget to propagate your changes by running "Configure -der". You may
# instead choose to run each of the .SH files by yourself, or "Configure -S".
#

# Configuration time: $cf_time
# Configured by: $cf_by
# Target system: $myuname

cf_by='$cf_by'
cf_time='$cf_time'
d_bsd='$d_bsd'
d_eunice='$d_eunice'
d_xenix='$d_xenix'
eunicefix='$eunicefix'
Mcc='$Mcc'
awk='$awk'
bash='$bash'
bison='$bison'
cat='$cat'
chgrp='$chgrp'
chmod='$chmod'
chown='$chown'
compress='$compress'
cp='$cp'
cpp='$cpp'
csh='$csh'
date='$date'
echo='$echo'
egrep='$egrep'
emacs='$emacs'
expr='$expr'
flex='$flex'
gcc='$gcc'
grep='$grep'
inews='$inews'
ispell='$ispell'
ispell_path='$ispell_path'
ispell_options='$ispell_options'
ksh='$ksh'
less='$less'
line='$line'
lint='$lint'
ln='$ln'
lp='$lp'
lpr='$lpr'
ls='$ls'
mail='$mail'
mailx='$mailx'
make='$make'
mkdir='$mkdir'
more='$more'
mv='$mv'
nroff='$nroff'
perl='$perl'
pg='$pg'
pmake='$pmake'
pr='$pr'
rm='$rm'
rmail='$rmail'
sed='$sed'
sendmail='$sendmail'
shar='$shar'
sleep='$sleep'
smail='$smail'
sort='$sort'
submit='$submit'
tail='$tail'
tar='$tar'
tbl='$tbl'
test='$test'
touch='$touch'
tr='$tr'
troff='$troff'
uname='$uname'
uniq='$uniq'
uuname='$uuname'
vi='$vi'
zcat='$zcat'
hint='$hint'
myuname='$myuname'
Author='$Author'
Date='$Date'
Header='$Header'
Id='$Id'
Locker='$Locker'
Log='$Log'
RCSfile='$RCSfile'
Revision='$Revision'
Source='$Source'
State='$State'
active='$active'
acttimes='$acttimes'
d_acttimes='$d_acttimes'
myactive='$myactive'
bin='$bin'
installbin='$installbin'
cc='$cc'
ccflags='$ccflags'
cppflags='$cppflags'
ldflags='$ldflags'
lkflags='$lkflags'
optimize='$optimize'
contains='$contains'
cppminus='$cppminus'
cppstdin='$cppstdin'
d_bcmp='$d_bcmp'
d_bcopy='$d_bcopy'
d_bzero='$d_bzero'
d_ftime='$d_ftime'
aphostcmd='$aphostcmd'
d_gethname='$d_gethname'
d_phostcmd='$d_phostcmd'
d_uname='$d_uname'
d_getpwent='$d_getpwent'
d_getcwd='$d_getcwd'
d_getwd='$d_getwd'
d_havetlib='$d_havetlib'
termlib='$termlib'
d_ignoreorg='$d_ignoreorg'
d_internet='$d_internet'
d_newsadm='$d_newsadm'
newsadmin='$newsadmin'
d_nntp='$d_nntp'
d_xdata='$d_xdata'
servername='$servername'
d_nolnbuf='$d_nolnbuf'
d_normsig='$d_normsig'
jobslib='$jobslib'
d_hvfork='$d_hvfork'
d_novfork='$d_novfork'
d_novoid='$d_novoid'
void='$void'
d_portable='$d_portable'
d_rdchk='$d_rdchk'
d_rename='$d_rename'
d_sigblock='$d_sigblock'
d_sighold='$d_sighold'
d_sizet='$d_sizet'
d_strchr='$d_strchr'
d_strftime='$d_strftime'
d_libndir='$d_libndir'
d_usendir='$d_usendir'
libndir='$libndir'
ndirc='$ndirc'
ndiro='$ndiro'
d_voidsig='$d_voidsig'
signal_t='$signal_t'
defeditor='$defeditor'
filexp='$filexp'
h_fcntl='$h_fcntl'
h_sysfile='$h_sysfile'
d_dirnamlen='$d_dirnamlen'
i_dirent='$i_dirent'
i_fcntl='$i_fcntl'
i_ptem='$i_ptem'
i_sysdir='$i_sysdir'
d_voidtty='$d_voidtty'
i_bsdioctl='$i_bsdioctl'
i_sysioctl='$i_sysioctl'
i_syssockio='$i_syssockio'
i_sysndir='$i_sysndir'
i_sgtty='$i_sgtty'
i_termio='$i_termio'
i_termios='$i_termios'
i_vfork='$i_vfork'
libc='$libc'
plibpth='$plibpth'
xlibpath='$xlibpath'
libs='$libs'
citydist='$citydist'
cntrydist='$cntrydist'
contdist='$contdist'
locdist='$locdist'
orgdist='$orgdist'
statedist='$statedist'
mailer='$mailer'
mailfile='$mailfile'
manext='$manext'
mansrc='$mansrc'
mboxchar='$mboxchar'
c='$c'
n='$n'
d_berknames='$d_berknames'
d_passnames='$d_passnames'
d_usgnames='$d_usgnames'
nametype='$nametype'
passcat='$passcat'
inewsloc='$inewsloc'
newslib='$newslib'
newslibexp='$newslibexp'
newsspool='$newsspool'
orgname='$orgname'
package='$package'
pager='$pager'
phost='$phost'
phostcmd='$phostcmd'
prefshell='$prefshell'
installprivlib='$installprivlib'
privlib='$privlib'
rootid='$rootid'
sharpbang='$sharpbang'
shsharp='$shsharp'
spitshell='$spitshell'
startsh='$startsh'
sysman='$sysman'
d_usemt='$d_usemt'
d_useov='$d_useov'
overviewdir='$overviewdir'
threaddir='$threaddir'
trn_init='$trn_init'
trn_select='$trn_select'
nm_opt='$nm_opt'
runnm='$runnm'
usenm='$usenm'
incpath='$incpath'
mips='$mips'
mips_type='$mips_type'
usrinc='$usrinc'
EOT

: add special variables
$test -f patchlevel.h && \
awk '/^#define/ {printf "%s=%s %s%s\n",$2,$3,$4,$5}' patchlevel.h >>config.sh
echo "CONFIG=true" >>config.sh

: Finish up by extracting the .SH files
case "$alldone" in
exit)
	$rm -rf UU
	echo "Done."
	exit 0
	;;
cont)
	;;
'')
	echo " "
	dflt=''
echo "If you didn't make any mistakes, then just type a carriage return here."
	rp="If you need to edit config.sh, do it as a shell escape here:"
	. ./UU/myread
	case "$ans" in
	'') ;;
	*) : in case they cannot read
		eval $ans;;
	esac
	;;
esac

: if this fails, just run all the .SH files by hand
. ./config.sh

echo " "
exec 1>&4
. ./UU/extract

if $contains '^depend:' [Mm]akefile >/dev/null 2>&1; then
	dflt=n
	case "$silent" in
	true) ;;
	*)
		$cat <<EOM

Now you need to generate make dependencies by running "make depend".
You might prefer to run it in background: "make depend > makedepend.out &"
It can take a while, so you might not want to run it right now.

EOM
		;;
	esac
	rp="Run make depend now?"
	. ./UU/myread
	case "$ans" in
	y*)
		make depend && echo "Now you must run a make."
		;;
	*)
		echo "You must run 'make depend' then 'make'."
		;;
	esac
elif test -f [Mm]akefile; then
	echo " "
	echo "Now you must run a make."
else
	echo "Done."
fi

$rm -f kit*isdone ark*isdone
$rm -rf UU
: End of Configure
