This is Info file ./gdb.info, produced by Makeinfo-1.47 from the input
file gdb-all.texi.

START-INFO-DIR-ENTRY
* Gdb: (gdb).                   The GNU debugger.
END-INFO-DIR-ENTRY
   This file documents the GNU debugger GDB.

   This is Edition 4.06, October 1992, of `Debugging with GDB: the GNU
Source-Level Debugger' for GDB Version 4.7.

   Copyright (C) 1988, 1989, 1990, 1991, 1992 Free Software Foundation,
Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: gdb.info,  Node: Returning,  Next: Calling,  Prev: Signaling,  Up: Altering

Returning from a Function
=========================

`return'
`return EXPRESSION'
     You can cancel execution of a function call with the `return'
     command.  If you give an EXPRESSION argument, its value is used as
     the function's return value.

   When you use `return', GDB discards the selected stack frame (and
all frames within it).  You can think of this as making the discarded
frame return prematurely.  If you wish to specify a value to be
returned, give that value as the argument to `return'.

   This pops the selected stack frame (*note Selecting a Frame:
Selection.), and any other frames inside of it, leaving its caller as
the innermost remaining frame.  That frame becomes selected.  The
specified value is stored in the registers used for returning values of
functions.

   The `return' command does not resume execution; it leaves the
program stopped in the state that would exist if the function had just
returned.  In contrast, the `finish' command (*note Continuing and
Stepping: Continuing and Stepping.) resumes execution until the
selected stack frame returns naturally.


File: gdb.info,  Node: Calling,  Next: Patching,  Prev: Returning,  Up: Altering

Calling your Program's Functions
================================

`call EXPR'
     Evaluate the expression EXPR without displaying `void' returned
     values.

   You can use this variant of the `print' command if you want to
execute a function from your program, but without cluttering the output
with `void' returned values.  The result is printed and saved in the
value history, if it is not void.


File: gdb.info,  Node: Patching,  Prev: Calling,  Up: Altering

Patching your Program
=====================

   By default, GDB opens the file containing your program's executable
code (or the corefile) read-only.  This prevents accidental alterations
to machine code; but it also prevents you from intentionally patching
your program's binary.

   If you'd like to be able to patch the binary, you can specify that
explicitly with the `set write' command.  For example, you might want
to turn on internal debugging flags, or even to make emergency repairs.

`set write on'
`set write off'
     If you specify `set write on', GDB will open executable and core
     files for both reading and writing; if you specify `set write off'
     (the default), GDB will open them read-only.

     If you have already loaded a file, you must load it again (using
     the `exec-file' or `core-file' command) after changing `set
     write', for your new setting to take effect.

`show write'
     Display whether executable files and core files will be opened for
     writing as well as reading.


File: gdb.info,  Node: GDB Files,  Next: Targets,  Prev: Altering,  Up: Top

GDB's Files
***********

   GDB needs to know the file name of the program to be debugged, both
in order to read its symbol table and in order to start your program.
To debug a core dump of a previous run, GDB must be told the file name
of the core dump.

* Menu:

* Files::                       Commands to Specify Files
* Symbol Errors::               Errors Reading Symbol Files


File: gdb.info,  Node: Files,  Next: Symbol Errors,  Up: GDB Files

Commands to Specify Files
=========================

   The usual way to specify executable and core dump file names is with
the command arguments given when you start GDB, (*note Getting In and
Out of GDB: Invocation..

   Occasionally it is necessary to change to a different file during a
GDB session.  Or you may run GDB and forget to specify a file you want
to use.  In these situations the GDB commands to specify new files are
useful.

`file FILENAME'
     Use FILENAME as the program to be debugged.  It is read for its
     symbols and for the contents of pure memory.  It is also the
     program executed when you use the `run' command.  If you do not
     specify a directory and the file is not found in GDB's working
     directory, GDB uses the environment variable `PATH' as a list of
     directories to search, just as the shell does when looking for a
     program to run.  You can change the value of this variable, for
     both GDB and your program, using the `path' command.

     On systems with memory-mapped files, an auxiliary symbol table file
     `FILENAME.syms' may be available for FILENAME.  If it is, GDB will
     map in the symbol table from `FILENAME.syms', starting up more
     quickly.  See the descriptions of the options `-mapped' and
     `-readnow' (available on the command line, and with the commands
     `file', `symbol-file', or `add-symbol-file'), for more information.

`file'
     `file' with no argument makes GDB discard any information it has
     on both executable file and the symbol table.

`exec-file [ FILENAME ]'
     Specify that the program to be run (but not the symbol table) is
     found in FILENAME.  GDB will search the environment variable `PATH'
     if necessary to locate your program.  Omitting FILENAME means to
     discard information on the executable file.

`symbol-file [ FILENAME ]'
     Read symbol table information from file FILENAME.  `PATH' is
     searched when necessary.  Use the `file' command to get both symbol
     table and program to run from the same file.

     `symbol-file' with no argument clears out GDB's information on your
     program's symbol table.

     The `symbol-file' command causes GDB to forget the contents of its
     convenience variables, the value history, and all breakpoints and
     auto-display expressions.  This is because they may contain
     pointers to the internal data recording symbols and data types,
     which are part of the old symbol table data being discarded inside
     GDB.

     `symbol-file' will not repeat if you press RET again after
     executing it once.

     When GDB is configured for a particular environment, it will
     understand debugging information in whatever format is the standard
     generated for that environment; you may use either a GNU compiler,
     or other compilers that adhere to the local conventions.  Best
     results are usually obtained from GNU compilers; for example,
     using `gcc' you can generate debugging information for optimized
     code.

     On some kinds of object files, the `symbol-file' command does not
     normally read the symbol table in full right away.  Instead, it
     scans the symbol table quickly to find which source files and
     which symbols are present.  The details are read later, one source
     file at a time, as they are needed.

     The purpose of this two-stage reading strategy is to make GDB
     start up faster.  For the most part, it is invisible except for
     occasional pauses while the symbol table details for a particular
     source file are being read.  (The `set verbose' command can turn
     these pauses into messages if desired. *Note Optional Warnings and
     Messages: Messages/Warnings.)

     When the symbol table is stored in COFF format, `symbol-file' does
     read the symbol table data in full right away.  We have not
     implemented the two-stage strategy for COFF yet.

`symbol-file FILENAME [ -readnow ] [ -mapped ]'
`file FILENAME [ -readnow ] [ -mapped ]'
     You can override the GDB two-stage strategy for reading symbol
     tables by using the `-readnow' option with any of the commands that
     load symbol table information, if you want to be sure GDB has the
     entire symbol table available.

     If memory-mapped files are available on your system through the
     `mmap' system call, you can use another option, `-mapped', to
     cause GDB to write the symbols for your program into a reusable
     file.  Future GDB debugging sessions will map in symbol information
     from this auxiliary symbol file (if the program hasn't changed),
     rather than spending time reading the symbol table from the
     executable program.  Using the `-mapped' option has the same
     effect as starting GDB with the `-mapped' command-line option.

     You can use both options together, to make sure the auxiliary
     symbol file has all the symbol information for your program.

     The `.syms' file is specific to the host machine on which GDB is
     run. It holds an exact image of GDB's internal symbol table.  It
     cannot be shared across multiple host platforms.

     The auxiliary symbol file for a program called MYPROG is called
     `MYPROG.syms'.  Once this file exists (so long as it is newer than
     the corresponding executable), GDB will always attempt to use it
     when you debug MYPROG; no special options or commands are needed.

`core-file [ FILENAME ]'
     Specify the whereabouts of a core dump file to be used as the
     "contents of memory".  Traditionally, core files contain only some
     parts of the address space of the process that generated them; GDB
     can access the executable file itself for other parts.

     `core-file' with no argument specifies that no core file is to be
     used.

     Note that the core file is ignored when your program is actually
     running under GDB.  So, if you have been running your program and
     you wish to debug a core file instead, you must kill the
     subprocess in which the program is running.  To do this, use the
     `kill' command (*note Killing the Child Process: Kill Process.).

`load FILENAME'
     Depending on what remote debugging facilities are configured into
     GDB, the `load' command may be available.  Where it exists, it is
     meant to make FILENAME (an executable) available for debugging on
     the remote system--by downloading, or dynamic linking, for example.
     `load' also records FILENAME's symbol table in GDB, like the
     `add-symbol-file' command.

     If `load' is not available on your GDB, attempting to execute it
     gets the error message "`You can't do that when your target is
     ...'"

     On VxWorks, `load' will dynamically link FILENAME on the current
     target system as well as adding its symbols in GDB.

     With the Nindy interface to an Intel 960 board, `load' will
     download FILENAME to the 960 as well as adding its symbols in GDB.

     When you select remote debugging to a Hitachi H8/300 board (*note
     GDB and the Hitachi H8/300: Hitachi H8/300 Remote.), the `load'
     command downloads your program to the H8/300 and also opens it as
     the current executable target for GDB on your host (like the
     `file' command).

     `load' will not repeat if you press RET again after using it.

`add-symbol-file FILENAME ADDRESS'
`add-symbol-file FILENAME ADDRESS [ -readnow ] [ -mapped ]'
     The `add-symbol-file' command reads additional symbol table
     information from the file FILENAME.  You would use this command
     when FILENAME has been dynamically loaded (by some other means)
     into the program that is running.  ADDRESS should be the memory
     address at which the file has been loaded; GDB cannot figure this
     out for itself.

     The symbol table of the file FILENAME is added to the symbol table
     originally read with the `symbol-file' command.  You can use the
     `add-symbol-file' command any number of times; the new symbol data
     thus read keeps adding to the old.  To discard all old symbol data
     instead, use the `symbol-file' command.

     `add-symbol-file' will not repeat if you press RET after using it.

     You can use the `-mapped' and `-readnow' options just as with the
     `symbol-file' command, to change how GDB manages the symbol table
     information for FILENAME.

`info files'
`info target'
     `info files' and `info target' are synonymous; both print the
     current targets (*note Specifying a Debugging Target: Targets.),
     including the names of the executable and core dump files
     currently in use by GDB, and the files from which symbols were
     loaded.  The command `help targets' lists all possible targets
     rather than current ones.

   All file-specifying commands allow both absolute and relative file
names as arguments.  GDB always converts the file name to an absolute
path name and remembers it that way.

   GDB supports SunOS, SVR4, and IBM RS/6000 shared libraries. GDB
automatically loads symbol definitions from shared libraries when you
use the `run' command, or when you examine a core file. (Before you
issue the `run' command, GDB will not understand references to a
function in a shared library, however--unless you are debugging a core
file).

`info share'
`info sharedlibrary'
     Print the names of the shared libraries which are currently loaded.

`sharedlibrary REGEX'
`share REGEX'
     This is an obsolescent command; you can use it to explicitly load
     shared object library symbols for files matching a UNIX regular
     expression, but as with files loaded automatically, it will only
     load shared libraries required by your program for a core file or
     after typing `run'.  If REGEX is omitted all shared libraries
     required by your program are loaded.


File: gdb.info,  Node: Symbol Errors,  Prev: Files,  Up: GDB Files

Errors Reading Symbol Files
===========================

   While reading a symbol file, GDB will occasionally encounter
problems, such as symbol types it does not recognize, or known bugs in
compiler output.  By default, GDB does not notify you of such problems,
since they are relatively common and primarily of interest to people
debugging compilers.  If you are interested in seeing information about
ill-constructed symbol tables, you can either ask GDB to print only one
message about each such type of problem, no matter how many times the
problem occurs; or you can ask GDB to print more messages, to see how
many times the problems occur, with the `set complaints' command (*note
Optional Warnings and Messages: Messages/Warnings.).

   The messages currently printed, and their meanings, are:

`inner block not inside outer block in SYMBOL'
     The symbol information shows where symbol scopes begin and end
     (such as at the start of a function or a block of statements). 
     This error indicates that an inner scope block is not fully
     contained in its outer scope blocks.

     GDB circumvents the problem by treating the inner block as if it
     had the same scope as the outer block.  In the error message,
     SYMBOL may be shown as "`(don't know)'" if the outer block is not a
     function.

`block at ADDRESS out of order'
     The symbol information for symbol scope blocks should occur in
     order of increasing addresses.  This error indicates that it does
     not do so.

     GDB does not circumvent this problem, and will have trouble
     locating symbols in the source file whose symbols being read. 
     (You can often determine what source file is affected by
     specifying `set verbose on'.  *Note Optional Warnings and
     Messages: Messages/Warnings.)

`bad block start address patched'
     The symbol information for a symbol scope block has a start address
     smaller than the address of the preceding source line.  This is
     known to occur in the SunOS 4.1.1 (and earlier) C compiler.

     GDB circumvents the problem by treating the symbol scope block as
     starting on the previous source line.

`bad string table offset in symbol N'
     Symbol number N contains a pointer into the string table which is
     larger than the size of the string table.

     GDB circumvents the problem by considering the symbol to have the
     name `foo', which may cause other problems if many symbols end up
     with this name.

`unknown symbol type `0xNN''
     The symbol information contains new data types that GDB does not
     yet know how to read.  `0xNN' is the symbol type of the
     misunderstood information, in hexadecimal.

     GDB circumvents the error by ignoring this symbol information. 
     This will usually allow your program to be debugged, though
     certain symbols will not be accessible.  If you encounter such a
     problem and feel like debugging it, you can debug `gdb' with
     itself, breakpoint on `complain', then go up to the function
     `read_dbx_symtab' and examine `*bufp' to see the symbol.

`stub type has NULL name'
     GDB could not find the full definition for a struct or class.

`const/volatile indicator missing (ok if using g++ v1.x), got...'
     The symbol information for a C++ member function is missing some
     information that recent versions of the compiler should have output
     for it.

`info mismatch between compiler and debugger'
     GDB could not parse a type specification output by the compiler.


File: gdb.info,  Node: Targets,  Next: Controlling GDB,  Prev: GDB Files,  Up: Top

Specifying a Debugging Target
*****************************

   A "target" is the execution environment occupied by your program.
Often, GDB runs in the same host environment as your program; in that
case, the debugging target is specified as a side effect when you use
the `file' or `core' commands.  When you need more flexibility--for
example, running GDB on a physically separate host, or controlling a
standalone system over a serial port or a realtime system over a TCP/IP
connection--you can use the `target' command to specify one of the
target types configured for GDB (*note Commands for Managing Targets:
Target Commands.).

* Menu:

* Active Targets::              Active Targets
* Target Commands::             Commands for Managing Targets
* Remote::                      Remote Debugging


File: gdb.info,  Node: Active Targets,  Next: Target Commands,  Up: Targets

Active Targets
==============

   There are three classes of targets: processes, core files, and
executable files.  GDB can work concurrently on up to three active
targets, one in each class.  This allows you to (for example) start a
process and inspect its activity without abandoning your work on a core
file.

   If, for example, you execute `gdb a.out', then the executable file
`a.out' is the only active target.  If you designate a core file as
well--presumably from a prior run that crashed and coredumped--then GDB
has two active targets and will use them in tandem, looking first in
the corefile target, then in the executable file, to satisfy requests
for memory addresses.  (Typically, these two classes of target are
complementary, since core files contain only a program's read-write
memory--variables and so on--plus machine status, while executable
files contain only the program text and initialized data.)

   When you type `run', your executable file becomes an active process
target as well.  When a process target is active, all GDB commands
requesting memory addresses refer to that target; addresses in an
active core file or executable file target are obscured while the
process target is active.

   Use the `core-file' and `exec-file' commands to select a new core
file or executable target (*note Commands to Specify Files: Files.). 
To specify as a target a process that is already running, use the
`attach' command (*note Debugging an Already-Running Process: Attach..).


File: gdb.info,  Node: Target Commands,  Next: Remote,  Prev: Active Targets,  Up: Targets

Commands for Managing Targets
=============================

`target TYPE PARAMETERS'
     Connects the GDB host environment to a target machine or process. 
     A target is typically a protocol for talking to debugging
     facilities.  You use the argument TYPE to specify the type or
     protocol of the target machine.

     Further PARAMETERS are interpreted by the target protocol, but
     typically include things like device names or host names to connect
     with, process numbers, and baud rates.

     The `target' command will not repeat if you press RET again after
     executing the command.

`help target'
     Displays the names of all targets available.  To display targets
     currently selected, use either `info target' or `info files'
     (*note Commands to Specify Files: Files.).

`help target NAME'
     Describe a particular target, including any parameters necessary to
     select it.

   Here are some common targets (available, or not, depending on the GDB
configuration):

`target exec PROG'
     An executable file.  `target exec PROG' is the same as `exec-file
     PROG'.

`target core FILENAME'
     A core dump file.  `target core FILENAME' is the same as
     `core-file FILENAME'.

`target remote DEV'
     Remote serial target in GDB-specific protocol.  The argument DEV
     specifies what serial device to use for the connection (e.g.
     `/dev/ttya'). *Note Remote Debugging: Remote.

`target amd-eb DEV SPEED PROG'
     Remote PC-resident AMD EB29K board, attached over serial lines.
     DEV is the serial device, as for `target remote'; SPEED allows you
     to specify the linespeed; and PROG is the name of the program to
     be debugged, as it appears to DOS on the PC. *Note GDB with a
     Remote EB29K: EB29K Remote.

`target hms'
     A Hitachi H8/300 board, attached via serial line to your host.  Use
     special commands `device' and `speed' to control the serial line
     and the communications speed used. *Note GDB and the Hitachi
     H8/300: Hitachi H8/300 Remote.

`target nindy DEVICENAME'
     An Intel 960 board controlled by a Nindy Monitor.  DEVICENAME is
     the name of the serial device to use for the connection, e.g.
     `/dev/ttya'.  *Note GDB with a Remote i960 (Nindy): i960-Nindy
     Remote.

`target st2000 DEV SPEED'
     A Tandem ST2000 phone switch, running Tandem's STDBUG protocol. 
     DEV is the name of the device attached to the ST2000 serial line;
     SPEED is the communication line speed.  The arguments are not used
     if GDB is configured to connect to the ST2000 using TCP or Telnet.
     *Note GDB with a Tandem ST2000: ST2000 Remote.

`target vxworks MACHINENAME'
     A VxWorks system, attached via TCP/IP.  The argument MACHINENAME
     is the target system's machine name or IP address. *Note GDB and
     VxWorks: VxWorks Remote.

   Different targets are available on different configurations of GDB;
your configuration may have more or fewer targets.


File: gdb.info,  Node: Remote,  Prev: Target Commands,  Up: Targets

Remote Debugging
================

   If you are trying to debug a program running on a machine that
cannot run GDB in the usual way, it is often useful to use remote
debugging.  For example, you might use remote debugging on an operating
system kernel, or on a small system which does not have a general
purpose operating system powerful enough to run a full-featured
debugger.

   Some configurations of GDB have special serial or TCP/IP interfaces
to make this work with particular debugging targets.  In addition, GDB
comes with a generic serial protocol (specific to GDB, but not specific
to any particular target system) which you can use if you write the
remote stubs--the code that will run on the remote system to
communicate with GDB.

   Other remote targets may be available in your configuration of GDB;
use `help targets' to list them.

* Menu:

* Remote Serial::               GDB remote serial protocol
* i960-Nindy Remote::		GDB with a remote i960 (Nindy)
* EB29K Remote::		GDB with a remote EB29K
* VxWorks Remote::		GDB and VxWorks
* ST2000 Remote::               GDB with a Tandem ST2000
* Hitachi H8/300 Remote::       GDB and the Hitachi H8/300


File: gdb.info,  Node: Remote Serial,  Next: i960-Nindy Remote,  Up: Remote

The GDB remote serial protocol
------------------------------

   To debug a program running on another machine (the debugging
"target" machine), you must first arrange for all the usual
prerequisites for the program to run by itself.  For example, for a C
program, you need

  1. A startup routine to set up the C runtime environment; these
     usually have a name like `crt0'.  The startup routine may be
     supplied by your hardware supplier, or you may have to write your
     own.

  2. You probably need a C subroutine library to support your program's
     subroutine calls, notably managing input and output.

  3. A way of getting your program to the other machine--for example, a
     download program.  These are often supplied by the hardware
     manufacturer, but you may have to write your own from hardware
     documentation.

   The next step is to arrange for your program to use a serial port to
communicate with the machine where GDB is running (the "host" machine).
 In general terms, the scheme looks like this:

*On the host,*
     GDB already understands how to use this protocol; when everything
     else is set up, you can simply use the `target remote' command
     (*note Specifying a Debugging Target: Targets.).

*On the target,*
     you must link with your program a few special-purpose subroutines
     that implement the GDB remote serial protocol.  The file
     containing these subroutines is called  a "debugging stub".

   The debugging stub is specific to the architecture of the remote
machine; for example, use `sparc-stub.c' to debug programs on SPARC
boards.

   These working remote stubs are distributed with GDB:

`sparc-stub.c'
     For SPARC architectures.

`m68k-stub.c'
     For Motorola 680x0 architectures.

`i386-stub.c'
     For Intel 386 and compatible architectures.

   The `README' file in the GDB distribution may list other recently
added stubs.

* Menu:

* stub contents::       What the stub can do for you
* bootstrapping::       What you must do for the stub
* debug session::       Putting it all together
* protocol::            Outline of the communication protocol


File: gdb.info,  Node: stub contents,  Next: bootstrapping,  Up: Remote Serial

What the stub can do for you
............................

   The debugging stub for your architecture supplies these three
subroutines:

`set_debug_traps'
     This routine arranges to transfer control to `handle_exception'
     when your program stops.  You must call this subroutine explicitly
     near the beginning of your program.

`handle_exception'
     This is the central workhorse, but your program never calls it
     explicitly--the setup code arranges for `handle_exception' to run
     when a trap is triggered.

     `handle_exception' takes control when your program stops during
     execution (for example, on a breakpoint), and mediates
     communications with GDB on the host machine.  This is where the
     communications protocol is implemented; `handle_exception' acts as
     the GDB representative on the target machine; it begins by sending
     summary information on the state of your program, then continues
     to execute, retrieving and transmitting any information GDB needs,
     until you execute a GDB command that makes your program resume; at
     that point, `handle_exception' returns control to your own code on
     the target machine.

`breakpoint'
     Use this auxiliary subroutine to make your program contain a
     breakpoint.  Depending on the particular situation, this may be
     the only way for GDB to get control.  For instance, if your target
     machine has some sort of interrupt button, you won't need to call
     this; pressing the interrupt button will transfer control to
     `handle_exception'--in efect, to GDB.  On some machines, simply
     receiving characters on the serial port may also trigger a trap;
     again, in that situation, you don't need to call `breakpoint' from
     your own program--simply running `target remote' from the host GDB
     session will get control.

     Call `breakpoint' if none of these is true, or if you simply want
     to make certain your program stops at a predetermined point for the
     start of your debugging session.


File: gdb.info,  Node: bootstrapping,  Next: debug session,  Prev: stub contents,  Up: Remote Serial

What you must do for the stub
.............................

   The debugging stubs that come with GDB are set up for a particular
chip architecture, but they have no information about the rest of your
debugging target machine.  To allow the stub to work, you must supply
these special low-level subroutines:

`int getDebugChar()'
     Write this subroutine to read a single character from the serial
     port. It may be identical to `getchar' for your target system; a
     different name is used to allow you to distinguish the two if you
     wish.

`void putDebugChar(int)'
     Write this subroutine to write a single character to the serial
     port. It may be identical to `putchar' for your target system; a
     different name is used to allow you to distinguish the two if you
     wish.

`void flush_i_cache()'
     Write this subroutine to flush the instruction cache, if any, on
     your target machine.  If there is no instruction cache, this
     subroutine may be a no-op.

     On target machines that have instruction caches, GDB requires this
     function to make certain that the state of your program is stable.

You must also make sure this library routine is available:

`void *memset(void *, int, int)'
     This is the standard library function `memset' that sets an area of
     memory to a known value.  If you have one of the free versions of
     `libc.a', `memset' can be found there; otherwise, you must either
     obtain it from your hardware manufacturer, or write your own.

   If you do not use the GNU C compiler, you may need other standard
library subroutines as well; this will vary from one stub to another,
but in general the stubs are likely to use any of the common library
subroutines which `gcc' generates as inline code.


File: gdb.info,  Node: debug session,  Next: protocol,  Prev: bootstrapping,  Up: Remote Serial

Putting it all together
.......................

   In summary, when your program is ready to debug, you must follow
these steps.

  1. Make sure you have the supporting low-level routines:
     `getDebugChar', `putDebugChar', `flush_i_cache', `memset'.

  2. Insert these lines near the top of your program:

          set_debug_traps();
          breakpoint();

  3. Compile and link together: your program, the GDB debugging stub for
     your target architecture, and the supporting subroutines.

  4. Make sure you have a serial connection between your target machine
     and the GDB host, and identify the serial port used for this on
     the host.

  5. Download your program to your target machine (or get it there by
     whatever means the manufacturer provides), and start it.

  6. To start remote debugging, run GDB on the host machine, and specify
     as an executable file the program that is running in the remote
     machine. This tells GDB how to find your program's symbols and the
     contents of its pure text.

     Then establish communication using the `target remote' command.
     Its argument is the name of the device you're using to control the
     target machine.  For example:

          target remote /dev/ttyb

     if the serial line is connected to the device named `/dev/ttyb'.


   Now you can use all the usual commands to examine and change data
and to step and continue the remote program.

   To resume the remote program and stop debugging it, use the `detach'
command.


File: gdb.info,  Node: protocol,  Prev: debug session,  Up: Remote Serial

Outline of the communication protocol
.....................................

   The stub files provided with GDB implement the target side of the
communication protocol, and the GDB side is implemented in the GDB
source file `remote.c'.  Normally, you can simply allow these
subroutines to communicate, and ignore the details.  (If you're
implementing your own stub file, you can still ignore the details: start
with one of the existing stub files.  `sparc-stub.c' is the best
organized, and therefore the easiest to read.)

   However, there may be occasions when you need to know something about
the protocol--for example, if there is only one serial port to your
target machine, you might want your program to do something special if
it recognizes a packet meant for GDB.

   All GDB commands and responses (other than acknowledgements, which
are single characters) are sent as a packet which includes a checksum. 
A packet is introduced with the character `$', and ends with the
character `#' followed by a two-digit checksum:

     $PACKET INFO#CHECKSUM

CHECKSUM is computed as the modulo 256 sum of the PACKET INFO
characters.

   When either the host or the target machine receives a packet, the
first response expected is an acknowledgement: a single character,
either `+' (to indicate the package was received correctly) or `-' (to
request retransmission).

   The host (GDB) sends commands, and the target (the debugging stub
incorporated in your program) sends data in response.  The target also
sends data when your program stops.

   Command packets are distinguished by their first character, which
identifies the kind of command.

   These are the commands currently supported:

`g'
     Requests the values of CPU registers.

`G'
     Sets the values of CPU registers.

`mADDR,COUNT'
     Read COUNT bytes at location ADDR.

`MADDR,COUNT:...'
     Write COUNT bytes at location ADDR.

`c'
`cADDR'
     Resume execution at the current address (or at ADDR if supplied).

`s'
`sADDR'
     Step the target program for one instruction, from either the
     current program counter or from ADDR if supplied.

`k'
     Kill the target program.

`?'
     Report the most recent signal.  To allow you to take advantage of
     the GDB signal handling commands, one of the functions of the
     debugging stub is to report CPU traps as the corresponding POSIX
     signal values.

   If you have trouble with the serial connection, you can use the
command `set remotedebug'.  This makes GDB report on all packets sent
back and forth across the serial line to the remote machine.  The
packet-debugging information is printed on the GDB standard output
stream.  `set remotedebug off' turns it off, and `show remotedebug'
will show you its current state.


File: gdb.info,  Node: i960-Nindy Remote,  Next: EB29K Remote,  Prev: Remote Serial,  Up: Remote

GDB with a Remote i960 (Nindy)
------------------------------

   "Nindy" is a ROM Monitor program for Intel 960 target systems.  When
GDB is configured to control a remote Intel 960 using Nindy, you can
tell GDB how to connect to the 960 in several ways:

   * Through command line options specifying serial port, version of the
     Nindy protocol, and communications speed;

   * By responding to a prompt on startup;

   * By using the `target' command at any point during your GDB
     session.  *Note Commands for Managing Targets: Target Commands.

* Menu:

* Nindy Startup::               Startup with Nindy
* Nindy Options::               Options for Nindy
* Nindy reset::                 Nindy Reset Command


File: gdb.info,  Node: Nindy Startup,  Next: Nindy Options,  Up: i960-Nindy Remote

Startup with Nindy
..................

   If you simply start `gdb' without using any command-line options,
you are prompted for what serial port to use, *before* you reach the
ordinary GDB prompt:

     Attach /dev/ttyNN -- specify NN, or "quit" to quit:

Respond to the prompt with whatever suffix (after `/dev/tty')
identifies the serial port you want to use.  You can, if you choose,
simply start up with no Nindy connection by responding to the prompt
with an empty line.  If you do this, and later wish to attach to Nindy,
use `target' (*note Commands for Managing Targets: Target Commands.).


File: gdb.info,  Node: Nindy Options,  Next: Nindy reset,  Prev: Nindy Startup,  Up: i960-Nindy Remote

Options for Nindy
.................

   These are the startup options for beginning your GDB session with a
Nindy-960 board attached:

`-r PORT'
     Specify the serial port name of a serial interface to be used to
     connect to the target system.  This option is only available when
     GDB is configured for the Intel 960 target architecture.  You may
     specify PORT as any of: a full pathname (e.g. `-r /dev/ttya'), a
     device name in `/dev' (e.g. `-r ttya'), or simply the unique
     suffix for a specific `tty' (e.g. `-r a').

`-O'
     (An uppercase letter "O", not a zero.)  Specify that GDB should use
     the "old" Nindy monitor protocol to connect to the target system.
     This option is only available when GDB is configured for the Intel
     960 target architecture.

          *Warning:* if you specify `-O', but are actually trying to
          connect to a target system that expects the newer protocol,
          the connection will fail, appearing to be a speed mismatch. 
          GDB will repeatedly attempt to reconnect at several different
          line speeds.  You can abort this process with an interrupt.

`-brk'
     Specify that GDB should first send a `BREAK' signal to the target
     system, in an attempt to reset it, before connecting to a Nindy
     target.

          *Warning:* Many target systems do not have the hardware that
          this requires; it only works with a few boards.

   The standard `-b' option controls the line speed used on the serial
port.


File: gdb.info,  Node: Nindy reset,  Prev: Nindy Options,  Up: i960-Nindy Remote

Nindy Reset Command
...................

`reset'
     For a Nindy target, this command sends a "break" to the remote
     target system; this is only useful if the target has been equipped
     with a circuit to perform a hard reset (or some other interesting
     action) when a break is detected.


File: gdb.info,  Node: EB29K Remote,  Next: VxWorks Remote,  Prev: i960-Nindy Remote,  Up: Remote

GDB with a Remote EB29K
-----------------------

   To use GDB from a Unix system to run programs on AMD's EB29K board
in a PC, you must first connect a serial cable between the PC and a
serial port on the Unix system.  In the following, we assume you've
hooked the cable between the PC's `COM1' port and `/dev/ttya' on the
Unix system.

* Menu:

* Comms (EB29K)::               Communications Setup
* gdb-EB29K::                   EB29K cross-debugging
* Remote Log::                  Remote Log


File: gdb.info,  Node: Comms (EB29K),  Next: gdb-EB29K,  Up: EB29K Remote

Communications Setup
....................

   The next step is to set up the PC's port, by doing something like the
following in DOS on the PC:

     C:\> MODE com1:9600,n,8,1,none

This example--run on an MS DOS 4.0 system--sets the PC port to 9600
bps, no parity, eight data bits, one stop bit, and no "retry" action;
you must match the communications parameters when establishing the Unix
end of the connection as well.

   To give control of the PC to the Unix side of the serial line, type
the following at the DOS console:

     C:\> CTTY com1

(Later, if you wish to return control to the DOS console, you can use
the command `CTTY con'--but you must send it over the device that had
control, in our example over the `COM1' serial line).

   From the Unix host, use a communications program such as `tip' or
`cu' to communicate with the PC; for example,

     cu -s 9600 -l /dev/ttya

The `cu' options shown specify, respectively, the linespeed and the
serial port to use.  If you use `tip' instead, your command line may
look something like the following:

     tip -9600 /dev/ttya

Your system may define a different name where our example uses
`/dev/ttya' as the argument to `tip'.  The communications parameters,
including which port to use, are associated with the `tip' argument in
the "remote" descriptions file--normally the system table `/etc/remote'.

   Using the `tip' or `cu' connection, change the DOS working directory
to the directory containing a copy of your 29K program, then start the
PC program `EBMON' (an EB29K control program supplied with your board
by AMD).  You should see an initial display from `EBMON' similar to the
one that follows, ending with the `EBMON' prompt `#'--

     C:\> G:
     
     G:\> CD \usr\joe\work29k
     
     G:\USR\JOE\WORK29K> EBMON
     Am29000 PC Coprocessor Board Monitor, version 3.0-18
     Copyright 1990 Advanced Micro Devices, Inc.
     Written by Gibbons and Associates, Inc.
     
     Enter '?' or 'H' for help
     
     PC Coprocessor Type   = EB29K
     I/O Base              = 0x208
     Memory Base           = 0xd0000
     
     Data Memory Size      = 2048KB
     Available I-RAM Range = 0x8000 to 0x1fffff
     Available D-RAM Range = 0x80002000 to 0x801fffff
     
     PageSize              = 0x400
     Register Stack Size   = 0x800
     Memory Stack Size     = 0x1800
     
     CPU PRL               = 0x3
     Am29027 Available     = No
     Byte Write Available  = Yes
     
     # ~.

   Then exit the `cu' or `tip' program (done in the example by typing
`~.' at the `EBMON' prompt).  `EBMON' will keep running, ready for GDB
to take over.

   For this example, we've assumed what is probably the most convenient
way to make sure the same 29K program is on both the PC and the Unix
system: a PC/NFS connection that establishes "drive `G:'" on the PC as
a file system on the Unix host.  If you do not have PC/NFS or something
similar connecting the two systems, you must arrange some other
way--perhaps floppy-disk transfer--of getting the 29K program from the
Unix system to the PC; GDB will *not* download it over the serial line.


File: gdb.info,  Node: gdb-EB29K,  Next: Remote Log,  Prev: Comms (EB29K),  Up: EB29K Remote

EB29K cross-debugging
.....................

   Finally, `cd' to the directory containing an image of your 29K
program on the Unix system, and start GDB--specifying as argument the
name of your 29K program:

     cd /usr/joe/work29k
     gdb myfoo

   Now you can use the `target' command:

     target amd-eb /dev/ttya 9600 MYFOO

In this example, we've assumed your program is in a file called
`myfoo'.  Note that the filename given as the last argument to `target
amd-eb' should be the name of the program as it appears to DOS. In our
example this is simply `MYFOO', but in general it can include a DOS
path, and depending on your transfer mechanism may not resemble the
name on the Unix side.

   At this point, you can set any breakpoints you wish; when you are
ready to see your program run on the 29K board, use the GDB command
`run'.

   To stop debugging the remote program, use the GDB `detach' command.

   To return control of the PC to its console, use `tip' or `cu' once
again, after your GDB session has concluded, to attach to `EBMON'.  You
can then type the command `q' to shut down `EBMON', returning control
to the DOS command-line interpreter. Type `CTTY con' to return command
input to the main DOS console, and type `~.' to leave `tip' or `cu'.


File: gdb.info,  Node: Remote Log,  Prev: gdb-EB29K,  Up: EB29K Remote

Remote Log
..........

   The `target amd-eb' command creates a file `eb.log' in the current
working directory, to help debug problems with the connection. `eb.log'
records all the output from `EBMON', including echoes of the commands
sent to it.  Running `tail -f' on this file in another window often
helps to understand trouble with `EBMON', or unexpected events on the
PC side of the connection.


File: gdb.info,  Node: ST2000 Remote,  Next: Hitachi H8/300 Remote,  Prev: VxWorks Remote,  Up: Remote

GDB with a Tandem ST2000
------------------------

   To connect your ST2000 to the host system, see the manufacturer's
manual.  Once the ST2000 is physically attached, you can run

     target st2000 DEV SPEED

to establish it as your debugging environment.

   The `load' and `attach' commands are *not* defined for this target;
you must load your program into the ST2000 as you normally would for
standalone operation.  GDB will read debugging information (such as
symbols) from a separate, debugging version of the program available on
your host computer.

   These auxiliary GDB commands are available to help you with the
ST2000 environment:

`st2000 COMMAND'
     Send a COMMAND to the STDBUG monitor.  See the manufacturer's
     manual for available commands.

`connect'
     Connect the controlling terminal to the STDBUG command monitor. 
     When you are done interacting with STDBUG, typing either of two
     character sequences will get you back to the GDB command prompt:
     `RET~.' (Return, followed by tilde and period) or `RET~C-d'
     (Return, followed by tilde and control-D).


File: gdb.info,  Node: VxWorks Remote,  Next: ST2000 Remote,  Prev: EB29K Remote,  Up: Remote

GDB and VxWorks
---------------

   GDB enables developers to spawn and debug tasks running on networked
VxWorks targets from a Unix host.  Already-running tasks spawned from
the VxWorks shell can also be debugged.  GDB uses code that runs on
both the UNIX host and on the VxWorks target.  The program `gdb' is
installed and executed on the UNIX host.

   The following information on connecting to VxWorks was current when
this manual was produced; newer releases of VxWorks may use revised
procedures.

   The remote debugging interface (RDB) routines are installed and
executed on the VxWorks target.  These routines are included in the
VxWorks library `rdb.a' and are incorporated into the system image when
source-level debugging is enabled in the VxWorks configuration.

   If you wish, you can define `INCLUDE_RDB' in the VxWorks
configuration file `configAll.h' to include the RDB interface routines
and spawn the source debugging task `tRdbTask' when VxWorks is booted. 
For more information on configuring and remaking VxWorks, see the
manufacturer's manual.

   Once you have included the RDB interface in your VxWorks system image
and set your Unix execution search path to find GDB, you are ready to
run GDB.  From your UNIX host, type:

     % gdb

   GDB will come up showing the prompt:

     (gdb)

* Menu:

* VxWorks connection::          Connecting to VxWorks
* VxWorks download::            VxWorks Download
* VxWorks attach::              Running Tasks


File: gdb.info,  Node: VxWorks connection,  Next: VxWorks download,  Up: VxWorks Remote

Connecting to VxWorks
.....................

   The GDB command `target' lets you connect to a VxWorks target on the
network.  To connect to a target whose host name is "`tt'", type:

     (gdb) target vxworks tt

   GDB will display a message similar to the following:

     Attaching remote machine across net... Success!

   GDB will then attempt to read the symbol tables of any object modules
loaded into the VxWorks target since it was last booted.  GDB locates
these files by searching the directories listed in the command search
path (*note Your Program's Environment: Environment.); if it fails to
find an object file, it will display a message such as:

     prog.o: No such file or directory.

   This will cause the `target' command to abort.  When this happens,
you should add the appropriate directory to the search path, with the
GDB command `path', and execute the `target' command again.


File: gdb.info,  Node: VxWorks download,  Next: VxWorks attach,  Prev: VxWorks connection,  Up: VxWorks Remote

VxWorks Download
................

   If you have connected to the VxWorks target and you want to debug an
object that has not yet been loaded, you can use the GDB `load' command
to download a file from UNIX to VxWorks incrementally.  The object file
given as an argument to the `load' command is actually opened twice:
first by the VxWorks target in order to download the code, then by GDB
in order to read the symbol table.  This can lead to problems if the
current working directories on the two systems differ. It is simplest
to set the working directory on both systems to the directory in which
the object file resides, and then to reference the file by its name,
without any path.  Thus, to load a program `prog.o', residing in
`wherever/vw/demo/rdb', on VxWorks type:

     -> cd "wherever/vw/demo/rdb"

   On GDB type:

     (gdb) cd wherever/vw/demo/rdb
     (gdb) load prog.o

   GDB will display a response similar to the following:

     Reading symbol data from wherever/vw/demo/rdb/prog.o... done.

   You can also use the `load' command to reload an object module after
editing and recompiling the corresponding source file.  Note that this
will cause GDB to delete all currently-defined breakpoints,
auto-displays, and convenience variables, and to clear the value
history.  (This is necessary in order to preserve the integrity of
debugger data structures that reference the target system's symbol
table.)


File: gdb.info,  Node: VxWorks attach,  Prev: VxWorks download,  Up: VxWorks Remote

Running Tasks
.............

   You can also attach to an existing task using the `attach' command as
follows:

     (gdb) attach TASK

where TASK is the VxWorks hexadecimal task ID.  The task can be running
or suspended when you attach to it.  If running, it will be suspended at
the time of attachment.

