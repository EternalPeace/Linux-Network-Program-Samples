@node internals
@chapter Internal Architecture of the Compiler

This is meant to describe the C++ frontend for gcc in detail.
Questions and comments to mrs@cygnus.com.

@index delete, two argument
For two argument delete, the second argument is always calculated by
``virtual_size ='' in the source.  It currently has a problem, in that
object size is not calculated by the virtual destructor and passed back
for the second parameter to delete.  Destructors need to return a value
just like constructors.

@index visibility checking
Visibility checking in general is unimplemented, there are a few cases
where it is implemented.  grok_enum_decls should be used in more places
to do visibility checking, but this is only the tip of a bigger problem.

@index volatile
volatile is not implemented in general.

@index const
const is completely implemented except for function overload selection.

@index protected base classes
Protected base classes are not fully implemented.

@item BLOCK_SUPERCONTEXT
In the outermost scope of each function, it points to the FUNCTION_DECL
node.  It aids in better DWARF support of inline functions.

@item DECL_CLASS_CONTEXT
Identifys the context that the _DECL was found in.

Has values of:

	RECORD_TYPE, or UNION_TYPE.

What things can this be used on:

	TYPE_DECLs, *_DECLs

@item DECL_NESTED_TYPENAME
Holds the fully qualified type name.  Example, Base::Derived.

Has values of:

	IDENTIFIER_NODE

What things can this be used on:

	TYPE_DECLs

@item TYPE_NAME
Names the type.

Has values of:

	0 for things that don't have names.
	should be IDENTIFIER_NODE for RECORD_TYPEs UNION_TYPEs and ENUM_TYPEs.
	TYPE_DECL for RECORD_TYPEs, UNION_TYPEs and ENUM_TYPEs, but shouldn't
		be.
	TYPE_DECL for typedefs, unsure why.

What things can one use this on:

	TYPE_DECLs
	RECORD_TYPEs
	UNION_TYPEs
	ENUM_TYPEs

How is it used:

	Used by dwarfout.c to fetch the name of structs, unoins and enums
	to create AT_name fields.

History:

	It currently points to the TYPE_DECL for RECORD_TYPEs,
	UNION_TYPEs and ENUM_TYPEs, but it should be history soon.

@item DECL_NAME

Has values of:

	0 for things that don't have names.
	IDENTIFIER_NODE for TYPE_DECLs.

@item TYPE_DECL
Used to represent typedefs, and used to represent bindings layers.

Components:

	DECL_NAME is the name of the typedef.  For example, foo would
	be found in the DECL_NAME slot when @code{typedef int foo;} is
	seen.

	DECL_SOURCE_LINE identifies what source line number in the
	source file the declaration was found at.  A value of 0
	indicates that this TYPE_DECL is just an internal binding layer
	marker, and does not correspond to a user suppiled typedef.

	DECL_SOURCE_FILE @xref{DECL_SOURCE_FILE}.

@item DECL_IGNORED_P
A bit that can be set to inform the debug information output routines in
the backend that a certain _DECL node should be totally ignored.

Used in cases where it is known that the debugging information will be
output in another file, or where a sub-type is known not to be needed
because the enclosing type is not needed.

A compiler constructed virtual destructor in derived classes that do not
define an exlicit destructor that was defined exlicit in a base class
has this bit set as well.  Also used on __FUNCTION__ and
__PRETTY_FUNCTION__ to mark they are ``compiler generated.''  c-decl and
c-lex.c both want DECL_IGNORED_P set for ``internally generated vars,''
and ``user-invisible variable.''

Functions built by the C++ front-end such as default destructors,
virtual desctructors and default constructors want to be marked that
they are compiler generated, but unsure why.

Currently, it is used in an absolute way in the C++ front-end, as an
optimization, to tell the debug information output routines to not
generate debugging information that will be output by another separately
compiled file.

@findex DECL_SOURCE_FILE
@item DECL_SOURCE_FILE
Identifies what source file a particular declaration was found in.

Has values of:

	"<built-in>" on TYPE_DECLs to mean the typedef is built in.

@item DECL_SOURCE_LINE
Identifies what source line number in the source file the declaration
was found at.

Has values of:

	0 for an undefined label.

	0 for TYPE_DECLs that are internally generated.

	0 for FUNCTION_DECLs for functions generated by the compiler.
		(not yet, but should be.)

@item DECL_VIRTUAL_P
A flag used on FIELD_DECLs and VAR_DECLs.  (Documentation in tree.h is
wrong.)  Used in VAR_DECLs to indicate that the variable is a vtable.
It is also used in FIELD_DECLs for vtable pointers.

What things can this be used on:

	FIELD_DECLs and VAR_DECLs.

@item DECL_VINDEX
Used for FUNCTION_DECLs in two different ways.  Before the structure
containing the FUNCTION_DECL is laid out, DECL_VINDEX may point to a
FUNCTION_DECL in a base class which is the FUNCTION_DECL which this
FUNCTION_DECL will replace as a virtual function.  When the class is
laid out, this pointer is changed to an INTEGER_CST node which is
suitable for use as an index into the virtual function table.

DECL_VINDEX may be a TREE_LIST, that would seem to be a list of
overridden FUNCTION_DECLs.  add_virtual_function has code to deal with
this when it uses the variable base_fndecl_list, but it would seem that
somehow, it is possible for the TREE_LIST to pursist until method_call,
and it should not.

@item TREE_USED

Has values of:

	0 for unused labels.

@item TREE_ADDRESSABLE
A flag that is set for any type that has a constructor.

@item CLASSTYPE_METHOD_VEC
The following is true after finish_struct has been called (on the
class?) but not before.  Before finish_struct is called, things are
different to some extent.  Contains a TREE_VEC of methods of the class.
The TREE_VEC_LENGTH is the number of differently named methods plus one
for the 0th entry.  The 0th entry is always allocated, and reserved for
ctors and dtors.  If there are none, TREE_VEC_ELT(N,0) == NULL_TREE.
Each entry of the TREE_VEC is a FUNCTION_DECL.  For each FUNCTION_DECL,
there is a DECL_CHAIN slot.  If the FUNCTION_DECL is the last one with a
given name, the DECL_CHAIN slot is NULL_TREE.  Otherwise it is the next
method that has the same name (but a different signature).  It would
seem that it is not true that because the DECL_CHAIN slot is used in
this way, we cannot call pushdecl to put the method in the global scope
(cause that would overwrite the TREE_CHAIN slot), because they use
different _CHAINs.

friends are kept in TREE_LISTs, so that there's no need to use their
TREE_CHAIN slot for anything.

Has values of:

	TREE_VEC
	
@item TYPE_METHOD
Related to CLASSTYPE_METHOD_VEC.  Chained together with TREE_CHAIN.
dbxout.c uses this to get at the methods of a class.

@item CLASSTYPE_TAGS
CLASSTYPE_TAGS is a linked (via TREE_CHAIN) list of member classes of a
class. TREE_PURPOSE is the name, TREE_VALUE is the type (pushclass scans
these and calls pushtag on them.)

finish_struct scans these to produce TYPE_DECLs to add to the
TYPE_FIELDS of the type.

It is expected that name found in the TREE_PURPOSE slot is unique,
resolve_scope_to_name is one such place that depends upon this
uniqueness.

@item TYPE_FIELDS
TYPE_FIELDS is a linked list (via TREE_CHAIN) of member types of a
class.  The list can contain TYPE_DECLs, but there can also be other
things in the list apparently.  See also CLASSTYPE_TAGS.

@item TREE_PRIVATE
Set for FIELD_DECLs by finish_struct.  But not uniformly set.

The following routines do something with PRIVATE visibility:
build_method_call, alter_visibility, finish_struct_methods,
finish_struct, convert_to_aggr, CWriteLanguageDecl, CWriteLanguageType,
CWriteUseObject, compute_visibility, lookup_field, dfs_pushdecl,
GNU_xref_member, dbxout_type_fields, dbxout_type_method_1

@item TREE_PROTECTED
The following routines do something with PROTECTED visibility:
build_method_call, alter_visibility, finish_struct, convert_to_aggr,
CWriteLanguageDecl, CWriteLanguageType, CWriteUseObject,
compute_visibility, lookup_field, GNU_xref_member, dbxout_type_fields,
dbxout_type_method_1
